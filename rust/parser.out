Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHAR
    COMMENT
    CRATE
    DOBLEQUOTE
    DYN
    ENUM
    EXTERN
    FOR
    IMPL
    IN
    MATCH
    MOD
    MOVE
    PUB
    QUOTE
    REF
    SELF
    STRING
    STRUCT
    SUPER
    TRAIT
    TYPE
    UNSAFE
    USE
    WHERE

Grammar

Rule 0     S' -> stmt
Rule 1     stmt -> decl_stmt
Rule 2     stmt -> expr_stmt
Rule 3     stmt -> SEMICOLON
Rule 4     decl_stmt -> item
Rule 5     decl_stmt -> let_decl
Rule 6     expr_stmt -> expr SEMICOLON
Rule 7     item -> fn_item
Rule 8     item -> const_item
Rule 9     item -> static_item
Rule 10    fn_item -> FN ID LPAREN RPAREN block_expr
Rule 11    const_item -> CONST ID COLON type ASSIGN expr SEMICOLON
Rule 12    static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON
Rule 13    let_decl -> LET MUT ID COLON type init SEMICOLON
Rule 14    let_decl -> LET MUT ID COLON type SEMICOLON
Rule 15    let_decl -> LET MUT ID init SEMICOLON
Rule 16    let_decl -> LET MUT ID SEMICOLON
Rule 17    let_decl -> LET ID COLON type init SEMICOLON
Rule 18    let_decl -> LET ID COLON type SEMICOLON
Rule 19    let_decl -> LET ID init SEMICOLON
Rule 20    let_decl -> LET ID SEMICOLON
Rule 21    init -> ASSIGN expr
Rule 22    init -> expr
Rule 23    expr -> literal
Rule 24    expr -> block_expr
Rule 25    expr -> binop_expr
Rule 26    expr -> paren_expr
Rule 27    expr -> while_expr
Rule 28    expr -> loop_expr
Rule 29    expr -> break_expr
Rule 30    expr -> continue_expr
Rule 31    expr -> if_expr
Rule 32    expr -> return_expr
Rule 33    block_expr -> LBRACKET stmt expr RBRACKET
Rule 34    block_expr -> LBRACKET item expr RBRACKET
Rule 35    block_expr -> LBRACKET expr RBRACKET
Rule 36    binop_expr -> expr binop expr
Rule 37    binop_expr -> type_cast_expr
Rule 38    binop_expr -> assignment_expr
Rule 39    binop_expr -> compound_assignment_expr
Rule 40    paren_expr -> LPAREN expr RPAREN
Rule 41    while_expr -> WHILE no_struct_literal_expr block_expr
Rule 42    loop_expr -> LOOP block_expr
Rule 43    break_expr -> BREAK
Rule 44    continue_expr -> CONTINUE
Rule 45    if_expr -> IF no_struct_literal_expr block_expr
Rule 46    if_expr -> IF no_struct_literal_expr block_expr else_tail
Rule 47    else_tail -> ELSE if_expr
Rule 48    else_tail -> ELSE block_expr
Rule 49    return_expr -> RETURN
Rule 50    return_expr -> RETURN expr
Rule 51    no_struct_literal_expr -> literal
Rule 52    no_struct_literal_expr -> literal binop literal
Rule 53    no_struct_literal_expr -> literal binop literal binop literal
Rule 54    lit_suffix -> ID
Rule 55    literal -> num_lit
Rule 56    literal -> bool_lit
Rule 57    literal -> lit_suffix
Rule 58    num_lit -> INTEGER
Rule 59    num_lit -> FLOAT
Rule 60    bool_lit -> TRUE
Rule 61    bool_lit -> FALSE
Rule 62    binop -> arith_op
Rule 63    binop -> bitwise_op
Rule 64    binop -> comp_op
Rule 65    arith_op -> PLUS
Rule 66    arith_op -> MINUS
Rule 67    arith_op -> MULT
Rule 68    arith_op -> DIVIDE
Rule 69    arith_op -> REMINDER
Rule 70    bitwise_op -> AND
Rule 71    bitwise_op -> OR
Rule 72    bitwise_op -> XOR
Rule 73    comp_op -> EQUALS
Rule 74    comp_op -> NE
Rule 75    comp_op -> LT
Rule 76    comp_op -> GT
Rule 77    comp_op -> LE
Rule 78    comp_op -> GE
Rule 79    type_cast_expr -> ID AS type
Rule 80    assignment_expr -> expr ASSIGN expr
Rule 81    compound_assignment_expr -> expr arith_op ASSIGN expr
Rule 82    compound_assignment_expr -> expr bitwise_op ASSIGN expr
Rule 83    type -> SIGNINTTYPE
Rule 84    type -> UNSIGNINTTYPE
Rule 85    type -> FLOATTYPE
Rule 86    type -> BOOLTYPE
Rule 87    type -> CHARTYPE

Terminals, with rules where they appear

AND                  : 70
AS                   : 79
ASSIGN               : 11 12 21 80 81 82
BOOLTYPE             : 86
BREAK                : 43
CHAR                 : 
CHARTYPE             : 87
COLON                : 11 12 13 14 17 18
COMMENT              : 
CONST                : 11
CONTINUE             : 44
CRATE                : 
DIVIDE               : 68
DOBLEQUOTE           : 
DYN                  : 
ELSE                 : 47 48
ENUM                 : 
EQUALS               : 73
EXTERN               : 
FALSE                : 61
FLOAT                : 59
FLOATTYPE            : 85
FN                   : 10
FOR                  : 
GE                   : 78
GT                   : 76
ID                   : 10 11 12 13 14 15 16 17 18 19 20 54 79
IF                   : 45 46
IMPL                 : 
IN                   : 
INTEGER              : 58
LBRACKET             : 33 34 35
LE                   : 77
LET                  : 13 14 15 16 17 18 19 20
LOOP                 : 42
LPAREN               : 10 40
LT                   : 75
MATCH                : 
MINUS                : 66
MOD                  : 
MOVE                 : 
MULT                 : 67
MUT                  : 13 14 15 16
NE                   : 74
OR                   : 71
PLUS                 : 65
PUB                  : 
QUOTE                : 
RBRACKET             : 33 34 35
REF                  : 
REMINDER             : 69
RETURN               : 49 50
RPAREN               : 10 40
SELF                 : 
SEMICOLON            : 3 6 11 12 13 14 15 16 17 18 19 20
SIGNINTTYPE          : 83
STATIC               : 12
STRING               : 
STRUCT               : 
SUPER                : 
TRAIT                : 
TRUE                 : 60
TYPE                 : 
UNSAFE               : 
UNSIGNINTTYPE        : 84
USE                  : 
WHERE                : 
WHILE                : 41
XOR                  : 72
error                : 

Nonterminals, with rules where they appear

arith_op             : 62 81
assignment_expr      : 38
binop                : 36 52 53 53
binop_expr           : 25
bitwise_op           : 63 82
block_expr           : 10 24 41 42 45 46 48
bool_lit             : 56
break_expr           : 29
comp_op              : 64
compound_assignment_expr : 39
const_item           : 8
continue_expr        : 30
decl_stmt            : 1
else_tail            : 46
expr                 : 6 11 12 21 22 33 34 35 36 36 40 50 80 80 81 81 82 82
expr_stmt            : 2
fn_item              : 7
if_expr              : 31 47
init                 : 13 15 17 19
item                 : 4 34
let_decl             : 5
lit_suffix           : 57
literal              : 23 51 52 52 53 53 53
loop_expr            : 28
no_struct_literal_expr : 41 45 46
num_lit              : 55
paren_expr           : 26
return_expr          : 32
static_item          : 9
stmt                 : 33 0
type                 : 11 12 13 14 17 18 79
type_cast_expr       : 37
while_expr           : 27

Parsing method: LALR

state 0

    (0) S' -> . stmt
    (1) stmt -> . decl_stmt
    (2) stmt -> . expr_stmt
    (3) stmt -> . SEMICOLON
    (4) decl_stmt -> . item
    (5) decl_stmt -> . let_decl
    (6) expr_stmt -> . expr SEMICOLON
    (7) item -> . fn_item
    (8) item -> . const_item
    (9) item -> . static_item
    (13) let_decl -> . LET MUT ID COLON type init SEMICOLON
    (14) let_decl -> . LET MUT ID COLON type SEMICOLON
    (15) let_decl -> . LET MUT ID init SEMICOLON
    (16) let_decl -> . LET MUT ID SEMICOLON
    (17) let_decl -> . LET ID COLON type init SEMICOLON
    (18) let_decl -> . LET ID COLON type SEMICOLON
    (19) let_decl -> . LET ID init SEMICOLON
    (20) let_decl -> . LET ID SEMICOLON
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (10) fn_item -> . FN ID LPAREN RPAREN block_expr
    (11) const_item -> . CONST ID COLON type ASSIGN expr SEMICOLON
    (12) static_item -> . STATIC ID COLON type ASSIGN expr SEMICOLON
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    SEMICOLON       shift and go to state 4
    LET             shift and go to state 11
    FN              shift and go to state 23
    CONST           shift and go to state 25
    STATIC          shift and go to state 26
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    stmt                           shift and go to state 1
    decl_stmt                      shift and go to state 2
    expr_stmt                      shift and go to state 3
    item                           shift and go to state 5
    let_decl                       shift and go to state 6
    expr                           shift and go to state 7
    fn_item                        shift and go to state 8
    const_item                     shift and go to state 9
    static_item                    shift and go to state 10
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 1

    (0) S' -> stmt .



state 2

    (1) stmt -> decl_stmt .

    $end            reduce using rule 1 (stmt -> decl_stmt .)
    LBRACKET        reduce using rule 1 (stmt -> decl_stmt .)
    LPAREN          reduce using rule 1 (stmt -> decl_stmt .)
    WHILE           reduce using rule 1 (stmt -> decl_stmt .)
    LOOP            reduce using rule 1 (stmt -> decl_stmt .)
    BREAK           reduce using rule 1 (stmt -> decl_stmt .)
    CONTINUE        reduce using rule 1 (stmt -> decl_stmt .)
    IF              reduce using rule 1 (stmt -> decl_stmt .)
    RETURN          reduce using rule 1 (stmt -> decl_stmt .)
    INTEGER         reduce using rule 1 (stmt -> decl_stmt .)
    FLOAT           reduce using rule 1 (stmt -> decl_stmt .)
    TRUE            reduce using rule 1 (stmt -> decl_stmt .)
    FALSE           reduce using rule 1 (stmt -> decl_stmt .)
    ID              reduce using rule 1 (stmt -> decl_stmt .)


state 3

    (2) stmt -> expr_stmt .

    $end            reduce using rule 2 (stmt -> expr_stmt .)
    LBRACKET        reduce using rule 2 (stmt -> expr_stmt .)
    LPAREN          reduce using rule 2 (stmt -> expr_stmt .)
    WHILE           reduce using rule 2 (stmt -> expr_stmt .)
    LOOP            reduce using rule 2 (stmt -> expr_stmt .)
    BREAK           reduce using rule 2 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 2 (stmt -> expr_stmt .)
    IF              reduce using rule 2 (stmt -> expr_stmt .)
    RETURN          reduce using rule 2 (stmt -> expr_stmt .)
    INTEGER         reduce using rule 2 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 2 (stmt -> expr_stmt .)
    TRUE            reduce using rule 2 (stmt -> expr_stmt .)
    FALSE           reduce using rule 2 (stmt -> expr_stmt .)
    ID              reduce using rule 2 (stmt -> expr_stmt .)


state 4

    (3) stmt -> SEMICOLON .

    $end            reduce using rule 3 (stmt -> SEMICOLON .)
    LBRACKET        reduce using rule 3 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 3 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 3 (stmt -> SEMICOLON .)
    LOOP            reduce using rule 3 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 3 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 3 (stmt -> SEMICOLON .)
    IF              reduce using rule 3 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 3 (stmt -> SEMICOLON .)
    INTEGER         reduce using rule 3 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 3 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 3 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 3 (stmt -> SEMICOLON .)
    ID              reduce using rule 3 (stmt -> SEMICOLON .)


state 5

    (4) decl_stmt -> item .

    $end            reduce using rule 4 (decl_stmt -> item .)


state 6

    (5) decl_stmt -> let_decl .

    $end            reduce using rule 5 (decl_stmt -> let_decl .)
    LBRACKET        reduce using rule 5 (decl_stmt -> let_decl .)
    LPAREN          reduce using rule 5 (decl_stmt -> let_decl .)
    WHILE           reduce using rule 5 (decl_stmt -> let_decl .)
    LOOP            reduce using rule 5 (decl_stmt -> let_decl .)
    BREAK           reduce using rule 5 (decl_stmt -> let_decl .)
    CONTINUE        reduce using rule 5 (decl_stmt -> let_decl .)
    IF              reduce using rule 5 (decl_stmt -> let_decl .)
    RETURN          reduce using rule 5 (decl_stmt -> let_decl .)
    INTEGER         reduce using rule 5 (decl_stmt -> let_decl .)
    FLOAT           reduce using rule 5 (decl_stmt -> let_decl .)
    TRUE            reduce using rule 5 (decl_stmt -> let_decl .)
    FALSE           reduce using rule 5 (decl_stmt -> let_decl .)
    ID              reduce using rule 5 (decl_stmt -> let_decl .)


state 7

    (6) expr_stmt -> expr . SEMICOLON
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    SEMICOLON       shift and go to state 44
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 8

    (7) item -> fn_item .

    $end            reduce using rule 7 (item -> fn_item .)
    LBRACKET        reduce using rule 7 (item -> fn_item .)
    LPAREN          reduce using rule 7 (item -> fn_item .)
    WHILE           reduce using rule 7 (item -> fn_item .)
    LOOP            reduce using rule 7 (item -> fn_item .)
    BREAK           reduce using rule 7 (item -> fn_item .)
    CONTINUE        reduce using rule 7 (item -> fn_item .)
    IF              reduce using rule 7 (item -> fn_item .)
    RETURN          reduce using rule 7 (item -> fn_item .)
    INTEGER         reduce using rule 7 (item -> fn_item .)
    FLOAT           reduce using rule 7 (item -> fn_item .)
    TRUE            reduce using rule 7 (item -> fn_item .)
    FALSE           reduce using rule 7 (item -> fn_item .)
    ID              reduce using rule 7 (item -> fn_item .)


state 9

    (8) item -> const_item .

    $end            reduce using rule 8 (item -> const_item .)
    LBRACKET        reduce using rule 8 (item -> const_item .)
    LPAREN          reduce using rule 8 (item -> const_item .)
    WHILE           reduce using rule 8 (item -> const_item .)
    LOOP            reduce using rule 8 (item -> const_item .)
    BREAK           reduce using rule 8 (item -> const_item .)
    CONTINUE        reduce using rule 8 (item -> const_item .)
    IF              reduce using rule 8 (item -> const_item .)
    RETURN          reduce using rule 8 (item -> const_item .)
    INTEGER         reduce using rule 8 (item -> const_item .)
    FLOAT           reduce using rule 8 (item -> const_item .)
    TRUE            reduce using rule 8 (item -> const_item .)
    FALSE           reduce using rule 8 (item -> const_item .)
    ID              reduce using rule 8 (item -> const_item .)


state 10

    (9) item -> static_item .

    $end            reduce using rule 9 (item -> static_item .)
    LBRACKET        reduce using rule 9 (item -> static_item .)
    LPAREN          reduce using rule 9 (item -> static_item .)
    WHILE           reduce using rule 9 (item -> static_item .)
    LOOP            reduce using rule 9 (item -> static_item .)
    BREAK           reduce using rule 9 (item -> static_item .)
    CONTINUE        reduce using rule 9 (item -> static_item .)
    IF              reduce using rule 9 (item -> static_item .)
    RETURN          reduce using rule 9 (item -> static_item .)
    INTEGER         reduce using rule 9 (item -> static_item .)
    FLOAT           reduce using rule 9 (item -> static_item .)
    TRUE            reduce using rule 9 (item -> static_item .)
    FALSE           reduce using rule 9 (item -> static_item .)
    ID              reduce using rule 9 (item -> static_item .)


state 11

    (13) let_decl -> LET . MUT ID COLON type init SEMICOLON
    (14) let_decl -> LET . MUT ID COLON type SEMICOLON
    (15) let_decl -> LET . MUT ID init SEMICOLON
    (16) let_decl -> LET . MUT ID SEMICOLON
    (17) let_decl -> LET . ID COLON type init SEMICOLON
    (18) let_decl -> LET . ID COLON type SEMICOLON
    (19) let_decl -> LET . ID init SEMICOLON
    (20) let_decl -> LET . ID SEMICOLON

    MUT             shift and go to state 64
    ID              shift and go to state 65


state 12

    (54) lit_suffix -> ID .
    (79) type_cast_expr -> ID . AS type

    SEMICOLON       reduce using rule 54 (lit_suffix -> ID .)
    ASSIGN          reduce using rule 54 (lit_suffix -> ID .)
    PLUS            reduce using rule 54 (lit_suffix -> ID .)
    MINUS           reduce using rule 54 (lit_suffix -> ID .)
    MULT            reduce using rule 54 (lit_suffix -> ID .)
    DIVIDE          reduce using rule 54 (lit_suffix -> ID .)
    REMINDER        reduce using rule 54 (lit_suffix -> ID .)
    AND             reduce using rule 54 (lit_suffix -> ID .)
    OR              reduce using rule 54 (lit_suffix -> ID .)
    XOR             reduce using rule 54 (lit_suffix -> ID .)
    EQUALS          reduce using rule 54 (lit_suffix -> ID .)
    NE              reduce using rule 54 (lit_suffix -> ID .)
    LT              reduce using rule 54 (lit_suffix -> ID .)
    GT              reduce using rule 54 (lit_suffix -> ID .)
    LE              reduce using rule 54 (lit_suffix -> ID .)
    GE              reduce using rule 54 (lit_suffix -> ID .)
    RPAREN          reduce using rule 54 (lit_suffix -> ID .)
    RBRACKET        reduce using rule 54 (lit_suffix -> ID .)
    AS              shift and go to state 66


state 13

    (23) expr -> literal .

    SEMICOLON       reduce using rule 23 (expr -> literal .)
    ASSIGN          reduce using rule 23 (expr -> literal .)
    PLUS            reduce using rule 23 (expr -> literal .)
    MINUS           reduce using rule 23 (expr -> literal .)
    MULT            reduce using rule 23 (expr -> literal .)
    DIVIDE          reduce using rule 23 (expr -> literal .)
    REMINDER        reduce using rule 23 (expr -> literal .)
    AND             reduce using rule 23 (expr -> literal .)
    OR              reduce using rule 23 (expr -> literal .)
    XOR             reduce using rule 23 (expr -> literal .)
    EQUALS          reduce using rule 23 (expr -> literal .)
    NE              reduce using rule 23 (expr -> literal .)
    LT              reduce using rule 23 (expr -> literal .)
    GT              reduce using rule 23 (expr -> literal .)
    LE              reduce using rule 23 (expr -> literal .)
    GE              reduce using rule 23 (expr -> literal .)
    RPAREN          reduce using rule 23 (expr -> literal .)
    RBRACKET        reduce using rule 23 (expr -> literal .)


state 14

    (24) expr -> block_expr .

    SEMICOLON       reduce using rule 24 (expr -> block_expr .)
    ASSIGN          reduce using rule 24 (expr -> block_expr .)
    PLUS            reduce using rule 24 (expr -> block_expr .)
    MINUS           reduce using rule 24 (expr -> block_expr .)
    MULT            reduce using rule 24 (expr -> block_expr .)
    DIVIDE          reduce using rule 24 (expr -> block_expr .)
    REMINDER        reduce using rule 24 (expr -> block_expr .)
    AND             reduce using rule 24 (expr -> block_expr .)
    OR              reduce using rule 24 (expr -> block_expr .)
    XOR             reduce using rule 24 (expr -> block_expr .)
    EQUALS          reduce using rule 24 (expr -> block_expr .)
    NE              reduce using rule 24 (expr -> block_expr .)
    LT              reduce using rule 24 (expr -> block_expr .)
    GT              reduce using rule 24 (expr -> block_expr .)
    LE              reduce using rule 24 (expr -> block_expr .)
    GE              reduce using rule 24 (expr -> block_expr .)
    RPAREN          reduce using rule 24 (expr -> block_expr .)
    RBRACKET        reduce using rule 24 (expr -> block_expr .)


state 15

    (25) expr -> binop_expr .

    SEMICOLON       reduce using rule 25 (expr -> binop_expr .)
    ASSIGN          reduce using rule 25 (expr -> binop_expr .)
    PLUS            reduce using rule 25 (expr -> binop_expr .)
    MINUS           reduce using rule 25 (expr -> binop_expr .)
    MULT            reduce using rule 25 (expr -> binop_expr .)
    DIVIDE          reduce using rule 25 (expr -> binop_expr .)
    REMINDER        reduce using rule 25 (expr -> binop_expr .)
    AND             reduce using rule 25 (expr -> binop_expr .)
    OR              reduce using rule 25 (expr -> binop_expr .)
    XOR             reduce using rule 25 (expr -> binop_expr .)
    EQUALS          reduce using rule 25 (expr -> binop_expr .)
    NE              reduce using rule 25 (expr -> binop_expr .)
    LT              reduce using rule 25 (expr -> binop_expr .)
    GT              reduce using rule 25 (expr -> binop_expr .)
    LE              reduce using rule 25 (expr -> binop_expr .)
    GE              reduce using rule 25 (expr -> binop_expr .)
    RPAREN          reduce using rule 25 (expr -> binop_expr .)
    RBRACKET        reduce using rule 25 (expr -> binop_expr .)


state 16

    (26) expr -> paren_expr .

    SEMICOLON       reduce using rule 26 (expr -> paren_expr .)
    ASSIGN          reduce using rule 26 (expr -> paren_expr .)
    PLUS            reduce using rule 26 (expr -> paren_expr .)
    MINUS           reduce using rule 26 (expr -> paren_expr .)
    MULT            reduce using rule 26 (expr -> paren_expr .)
    DIVIDE          reduce using rule 26 (expr -> paren_expr .)
    REMINDER        reduce using rule 26 (expr -> paren_expr .)
    AND             reduce using rule 26 (expr -> paren_expr .)
    OR              reduce using rule 26 (expr -> paren_expr .)
    XOR             reduce using rule 26 (expr -> paren_expr .)
    EQUALS          reduce using rule 26 (expr -> paren_expr .)
    NE              reduce using rule 26 (expr -> paren_expr .)
    LT              reduce using rule 26 (expr -> paren_expr .)
    GT              reduce using rule 26 (expr -> paren_expr .)
    LE              reduce using rule 26 (expr -> paren_expr .)
    GE              reduce using rule 26 (expr -> paren_expr .)
    RPAREN          reduce using rule 26 (expr -> paren_expr .)
    RBRACKET        reduce using rule 26 (expr -> paren_expr .)


state 17

    (27) expr -> while_expr .

    SEMICOLON       reduce using rule 27 (expr -> while_expr .)
    ASSIGN          reduce using rule 27 (expr -> while_expr .)
    PLUS            reduce using rule 27 (expr -> while_expr .)
    MINUS           reduce using rule 27 (expr -> while_expr .)
    MULT            reduce using rule 27 (expr -> while_expr .)
    DIVIDE          reduce using rule 27 (expr -> while_expr .)
    REMINDER        reduce using rule 27 (expr -> while_expr .)
    AND             reduce using rule 27 (expr -> while_expr .)
    OR              reduce using rule 27 (expr -> while_expr .)
    XOR             reduce using rule 27 (expr -> while_expr .)
    EQUALS          reduce using rule 27 (expr -> while_expr .)
    NE              reduce using rule 27 (expr -> while_expr .)
    LT              reduce using rule 27 (expr -> while_expr .)
    GT              reduce using rule 27 (expr -> while_expr .)
    LE              reduce using rule 27 (expr -> while_expr .)
    GE              reduce using rule 27 (expr -> while_expr .)
    RPAREN          reduce using rule 27 (expr -> while_expr .)
    RBRACKET        reduce using rule 27 (expr -> while_expr .)


state 18

    (28) expr -> loop_expr .

    SEMICOLON       reduce using rule 28 (expr -> loop_expr .)
    ASSIGN          reduce using rule 28 (expr -> loop_expr .)
    PLUS            reduce using rule 28 (expr -> loop_expr .)
    MINUS           reduce using rule 28 (expr -> loop_expr .)
    MULT            reduce using rule 28 (expr -> loop_expr .)
    DIVIDE          reduce using rule 28 (expr -> loop_expr .)
    REMINDER        reduce using rule 28 (expr -> loop_expr .)
    AND             reduce using rule 28 (expr -> loop_expr .)
    OR              reduce using rule 28 (expr -> loop_expr .)
    XOR             reduce using rule 28 (expr -> loop_expr .)
    EQUALS          reduce using rule 28 (expr -> loop_expr .)
    NE              reduce using rule 28 (expr -> loop_expr .)
    LT              reduce using rule 28 (expr -> loop_expr .)
    GT              reduce using rule 28 (expr -> loop_expr .)
    LE              reduce using rule 28 (expr -> loop_expr .)
    GE              reduce using rule 28 (expr -> loop_expr .)
    RPAREN          reduce using rule 28 (expr -> loop_expr .)
    RBRACKET        reduce using rule 28 (expr -> loop_expr .)


state 19

    (29) expr -> break_expr .

    SEMICOLON       reduce using rule 29 (expr -> break_expr .)
    ASSIGN          reduce using rule 29 (expr -> break_expr .)
    PLUS            reduce using rule 29 (expr -> break_expr .)
    MINUS           reduce using rule 29 (expr -> break_expr .)
    MULT            reduce using rule 29 (expr -> break_expr .)
    DIVIDE          reduce using rule 29 (expr -> break_expr .)
    REMINDER        reduce using rule 29 (expr -> break_expr .)
    AND             reduce using rule 29 (expr -> break_expr .)
    OR              reduce using rule 29 (expr -> break_expr .)
    XOR             reduce using rule 29 (expr -> break_expr .)
    EQUALS          reduce using rule 29 (expr -> break_expr .)
    NE              reduce using rule 29 (expr -> break_expr .)
    LT              reduce using rule 29 (expr -> break_expr .)
    GT              reduce using rule 29 (expr -> break_expr .)
    LE              reduce using rule 29 (expr -> break_expr .)
    GE              reduce using rule 29 (expr -> break_expr .)
    RPAREN          reduce using rule 29 (expr -> break_expr .)
    RBRACKET        reduce using rule 29 (expr -> break_expr .)


state 20

    (30) expr -> continue_expr .

    SEMICOLON       reduce using rule 30 (expr -> continue_expr .)
    ASSIGN          reduce using rule 30 (expr -> continue_expr .)
    PLUS            reduce using rule 30 (expr -> continue_expr .)
    MINUS           reduce using rule 30 (expr -> continue_expr .)
    MULT            reduce using rule 30 (expr -> continue_expr .)
    DIVIDE          reduce using rule 30 (expr -> continue_expr .)
    REMINDER        reduce using rule 30 (expr -> continue_expr .)
    AND             reduce using rule 30 (expr -> continue_expr .)
    OR              reduce using rule 30 (expr -> continue_expr .)
    XOR             reduce using rule 30 (expr -> continue_expr .)
    EQUALS          reduce using rule 30 (expr -> continue_expr .)
    NE              reduce using rule 30 (expr -> continue_expr .)
    LT              reduce using rule 30 (expr -> continue_expr .)
    GT              reduce using rule 30 (expr -> continue_expr .)
    LE              reduce using rule 30 (expr -> continue_expr .)
    GE              reduce using rule 30 (expr -> continue_expr .)
    RPAREN          reduce using rule 30 (expr -> continue_expr .)
    RBRACKET        reduce using rule 30 (expr -> continue_expr .)


state 21

    (31) expr -> if_expr .

    SEMICOLON       reduce using rule 31 (expr -> if_expr .)
    ASSIGN          reduce using rule 31 (expr -> if_expr .)
    PLUS            reduce using rule 31 (expr -> if_expr .)
    MINUS           reduce using rule 31 (expr -> if_expr .)
    MULT            reduce using rule 31 (expr -> if_expr .)
    DIVIDE          reduce using rule 31 (expr -> if_expr .)
    REMINDER        reduce using rule 31 (expr -> if_expr .)
    AND             reduce using rule 31 (expr -> if_expr .)
    OR              reduce using rule 31 (expr -> if_expr .)
    XOR             reduce using rule 31 (expr -> if_expr .)
    EQUALS          reduce using rule 31 (expr -> if_expr .)
    NE              reduce using rule 31 (expr -> if_expr .)
    LT              reduce using rule 31 (expr -> if_expr .)
    GT              reduce using rule 31 (expr -> if_expr .)
    LE              reduce using rule 31 (expr -> if_expr .)
    GE              reduce using rule 31 (expr -> if_expr .)
    RPAREN          reduce using rule 31 (expr -> if_expr .)
    RBRACKET        reduce using rule 31 (expr -> if_expr .)


state 22

    (32) expr -> return_expr .

    SEMICOLON       reduce using rule 32 (expr -> return_expr .)
    ASSIGN          reduce using rule 32 (expr -> return_expr .)
    PLUS            reduce using rule 32 (expr -> return_expr .)
    MINUS           reduce using rule 32 (expr -> return_expr .)
    MULT            reduce using rule 32 (expr -> return_expr .)
    DIVIDE          reduce using rule 32 (expr -> return_expr .)
    REMINDER        reduce using rule 32 (expr -> return_expr .)
    AND             reduce using rule 32 (expr -> return_expr .)
    OR              reduce using rule 32 (expr -> return_expr .)
    XOR             reduce using rule 32 (expr -> return_expr .)
    EQUALS          reduce using rule 32 (expr -> return_expr .)
    NE              reduce using rule 32 (expr -> return_expr .)
    LT              reduce using rule 32 (expr -> return_expr .)
    GT              reduce using rule 32 (expr -> return_expr .)
    LE              reduce using rule 32 (expr -> return_expr .)
    GE              reduce using rule 32 (expr -> return_expr .)
    RPAREN          reduce using rule 32 (expr -> return_expr .)
    RBRACKET        reduce using rule 32 (expr -> return_expr .)


state 23

    (10) fn_item -> FN . ID LPAREN RPAREN block_expr

    ID              shift and go to state 67


state 24

    (40) paren_expr -> LPAREN . expr RPAREN
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 68
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 25

    (11) const_item -> CONST . ID COLON type ASSIGN expr SEMICOLON

    ID              shift and go to state 69


state 26

    (12) static_item -> STATIC . ID COLON type ASSIGN expr SEMICOLON

    ID              shift and go to state 70


state 27

    (55) literal -> num_lit .

    SEMICOLON       reduce using rule 55 (literal -> num_lit .)
    ASSIGN          reduce using rule 55 (literal -> num_lit .)
    PLUS            reduce using rule 55 (literal -> num_lit .)
    MINUS           reduce using rule 55 (literal -> num_lit .)
    MULT            reduce using rule 55 (literal -> num_lit .)
    DIVIDE          reduce using rule 55 (literal -> num_lit .)
    REMINDER        reduce using rule 55 (literal -> num_lit .)
    AND             reduce using rule 55 (literal -> num_lit .)
    OR              reduce using rule 55 (literal -> num_lit .)
    XOR             reduce using rule 55 (literal -> num_lit .)
    EQUALS          reduce using rule 55 (literal -> num_lit .)
    NE              reduce using rule 55 (literal -> num_lit .)
    LT              reduce using rule 55 (literal -> num_lit .)
    GT              reduce using rule 55 (literal -> num_lit .)
    LE              reduce using rule 55 (literal -> num_lit .)
    GE              reduce using rule 55 (literal -> num_lit .)
    RPAREN          reduce using rule 55 (literal -> num_lit .)
    RBRACKET        reduce using rule 55 (literal -> num_lit .)
    LBRACKET        reduce using rule 55 (literal -> num_lit .)


state 28

    (56) literal -> bool_lit .

    SEMICOLON       reduce using rule 56 (literal -> bool_lit .)
    ASSIGN          reduce using rule 56 (literal -> bool_lit .)
    PLUS            reduce using rule 56 (literal -> bool_lit .)
    MINUS           reduce using rule 56 (literal -> bool_lit .)
    MULT            reduce using rule 56 (literal -> bool_lit .)
    DIVIDE          reduce using rule 56 (literal -> bool_lit .)
    REMINDER        reduce using rule 56 (literal -> bool_lit .)
    AND             reduce using rule 56 (literal -> bool_lit .)
    OR              reduce using rule 56 (literal -> bool_lit .)
    XOR             reduce using rule 56 (literal -> bool_lit .)
    EQUALS          reduce using rule 56 (literal -> bool_lit .)
    NE              reduce using rule 56 (literal -> bool_lit .)
    LT              reduce using rule 56 (literal -> bool_lit .)
    GT              reduce using rule 56 (literal -> bool_lit .)
    LE              reduce using rule 56 (literal -> bool_lit .)
    GE              reduce using rule 56 (literal -> bool_lit .)
    RPAREN          reduce using rule 56 (literal -> bool_lit .)
    RBRACKET        reduce using rule 56 (literal -> bool_lit .)
    LBRACKET        reduce using rule 56 (literal -> bool_lit .)


state 29

    (57) literal -> lit_suffix .

    SEMICOLON       reduce using rule 57 (literal -> lit_suffix .)
    ASSIGN          reduce using rule 57 (literal -> lit_suffix .)
    PLUS            reduce using rule 57 (literal -> lit_suffix .)
    MINUS           reduce using rule 57 (literal -> lit_suffix .)
    MULT            reduce using rule 57 (literal -> lit_suffix .)
    DIVIDE          reduce using rule 57 (literal -> lit_suffix .)
    REMINDER        reduce using rule 57 (literal -> lit_suffix .)
    AND             reduce using rule 57 (literal -> lit_suffix .)
    OR              reduce using rule 57 (literal -> lit_suffix .)
    XOR             reduce using rule 57 (literal -> lit_suffix .)
    EQUALS          reduce using rule 57 (literal -> lit_suffix .)
    NE              reduce using rule 57 (literal -> lit_suffix .)
    LT              reduce using rule 57 (literal -> lit_suffix .)
    GT              reduce using rule 57 (literal -> lit_suffix .)
    LE              reduce using rule 57 (literal -> lit_suffix .)
    GE              reduce using rule 57 (literal -> lit_suffix .)
    RPAREN          reduce using rule 57 (literal -> lit_suffix .)
    RBRACKET        reduce using rule 57 (literal -> lit_suffix .)
    LBRACKET        reduce using rule 57 (literal -> lit_suffix .)


state 30

    (33) block_expr -> LBRACKET . stmt expr RBRACKET
    (34) block_expr -> LBRACKET . item expr RBRACKET
    (35) block_expr -> LBRACKET . expr RBRACKET
    (1) stmt -> . decl_stmt
    (2) stmt -> . expr_stmt
    (3) stmt -> . SEMICOLON
    (7) item -> . fn_item
    (8) item -> . const_item
    (9) item -> . static_item
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (4) decl_stmt -> . item
    (5) decl_stmt -> . let_decl
    (6) expr_stmt -> . expr SEMICOLON
    (10) fn_item -> . FN ID LPAREN RPAREN block_expr
    (11) const_item -> . CONST ID COLON type ASSIGN expr SEMICOLON
    (12) static_item -> . STATIC ID COLON type ASSIGN expr SEMICOLON
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (13) let_decl -> . LET MUT ID COLON type init SEMICOLON
    (14) let_decl -> . LET MUT ID COLON type SEMICOLON
    (15) let_decl -> . LET MUT ID init SEMICOLON
    (16) let_decl -> . LET MUT ID SEMICOLON
    (17) let_decl -> . LET ID COLON type init SEMICOLON
    (18) let_decl -> . LET ID COLON type SEMICOLON
    (19) let_decl -> . LET ID init SEMICOLON
    (20) let_decl -> . LET ID SEMICOLON
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    SEMICOLON       shift and go to state 4
    FN              shift and go to state 23
    CONST           shift and go to state 25
    STATIC          shift and go to state 26
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    LET             shift and go to state 11
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    stmt                           shift and go to state 71
    expr                           shift and go to state 72
    item                           shift and go to state 73
    decl_stmt                      shift and go to state 2
    expr_stmt                      shift and go to state 3
    fn_item                        shift and go to state 8
    const_item                     shift and go to state 9
    static_item                    shift and go to state 10
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    let_decl                       shift and go to state 6
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 31

    (37) binop_expr -> type_cast_expr .

    SEMICOLON       reduce using rule 37 (binop_expr -> type_cast_expr .)
    ASSIGN          reduce using rule 37 (binop_expr -> type_cast_expr .)
    PLUS            reduce using rule 37 (binop_expr -> type_cast_expr .)
    MINUS           reduce using rule 37 (binop_expr -> type_cast_expr .)
    MULT            reduce using rule 37 (binop_expr -> type_cast_expr .)
    DIVIDE          reduce using rule 37 (binop_expr -> type_cast_expr .)
    REMINDER        reduce using rule 37 (binop_expr -> type_cast_expr .)
    AND             reduce using rule 37 (binop_expr -> type_cast_expr .)
    OR              reduce using rule 37 (binop_expr -> type_cast_expr .)
    XOR             reduce using rule 37 (binop_expr -> type_cast_expr .)
    EQUALS          reduce using rule 37 (binop_expr -> type_cast_expr .)
    NE              reduce using rule 37 (binop_expr -> type_cast_expr .)
    LT              reduce using rule 37 (binop_expr -> type_cast_expr .)
    GT              reduce using rule 37 (binop_expr -> type_cast_expr .)
    LE              reduce using rule 37 (binop_expr -> type_cast_expr .)
    GE              reduce using rule 37 (binop_expr -> type_cast_expr .)
    RPAREN          reduce using rule 37 (binop_expr -> type_cast_expr .)
    RBRACKET        reduce using rule 37 (binop_expr -> type_cast_expr .)


state 32

    (38) binop_expr -> assignment_expr .

    SEMICOLON       reduce using rule 38 (binop_expr -> assignment_expr .)
    ASSIGN          reduce using rule 38 (binop_expr -> assignment_expr .)
    PLUS            reduce using rule 38 (binop_expr -> assignment_expr .)
    MINUS           reduce using rule 38 (binop_expr -> assignment_expr .)
    MULT            reduce using rule 38 (binop_expr -> assignment_expr .)
    DIVIDE          reduce using rule 38 (binop_expr -> assignment_expr .)
    REMINDER        reduce using rule 38 (binop_expr -> assignment_expr .)
    AND             reduce using rule 38 (binop_expr -> assignment_expr .)
    OR              reduce using rule 38 (binop_expr -> assignment_expr .)
    XOR             reduce using rule 38 (binop_expr -> assignment_expr .)
    EQUALS          reduce using rule 38 (binop_expr -> assignment_expr .)
    NE              reduce using rule 38 (binop_expr -> assignment_expr .)
    LT              reduce using rule 38 (binop_expr -> assignment_expr .)
    GT              reduce using rule 38 (binop_expr -> assignment_expr .)
    LE              reduce using rule 38 (binop_expr -> assignment_expr .)
    GE              reduce using rule 38 (binop_expr -> assignment_expr .)
    RPAREN          reduce using rule 38 (binop_expr -> assignment_expr .)
    RBRACKET        reduce using rule 38 (binop_expr -> assignment_expr .)


state 33

    (39) binop_expr -> compound_assignment_expr .

    SEMICOLON       reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    ASSIGN          reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    PLUS            reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    MINUS           reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    MULT            reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    DIVIDE          reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    REMINDER        reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    AND             reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    OR              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    XOR             reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    EQUALS          reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    NE              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    LT              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    GT              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    LE              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    GE              reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    RPAREN          reduce using rule 39 (binop_expr -> compound_assignment_expr .)
    RBRACKET        reduce using rule 39 (binop_expr -> compound_assignment_expr .)


state 34

    (41) while_expr -> WHILE . no_struct_literal_expr block_expr
    (51) no_struct_literal_expr -> . literal
    (52) no_struct_literal_expr -> . literal binop literal
    (53) no_struct_literal_expr -> . literal binop literal binop literal
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID

    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 76

    no_struct_literal_expr         shift and go to state 74
    literal                        shift and go to state 75
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29

state 35

    (42) loop_expr -> LOOP . block_expr
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 30

    block_expr                     shift and go to state 77

state 36

    (43) break_expr -> BREAK .

    SEMICOLON       reduce using rule 43 (break_expr -> BREAK .)
    ASSIGN          reduce using rule 43 (break_expr -> BREAK .)
    PLUS            reduce using rule 43 (break_expr -> BREAK .)
    MINUS           reduce using rule 43 (break_expr -> BREAK .)
    MULT            reduce using rule 43 (break_expr -> BREAK .)
    DIVIDE          reduce using rule 43 (break_expr -> BREAK .)
    REMINDER        reduce using rule 43 (break_expr -> BREAK .)
    AND             reduce using rule 43 (break_expr -> BREAK .)
    OR              reduce using rule 43 (break_expr -> BREAK .)
    XOR             reduce using rule 43 (break_expr -> BREAK .)
    EQUALS          reduce using rule 43 (break_expr -> BREAK .)
    NE              reduce using rule 43 (break_expr -> BREAK .)
    LT              reduce using rule 43 (break_expr -> BREAK .)
    GT              reduce using rule 43 (break_expr -> BREAK .)
    LE              reduce using rule 43 (break_expr -> BREAK .)
    GE              reduce using rule 43 (break_expr -> BREAK .)
    RPAREN          reduce using rule 43 (break_expr -> BREAK .)
    RBRACKET        reduce using rule 43 (break_expr -> BREAK .)


state 37

    (44) continue_expr -> CONTINUE .

    SEMICOLON       reduce using rule 44 (continue_expr -> CONTINUE .)
    ASSIGN          reduce using rule 44 (continue_expr -> CONTINUE .)
    PLUS            reduce using rule 44 (continue_expr -> CONTINUE .)
    MINUS           reduce using rule 44 (continue_expr -> CONTINUE .)
    MULT            reduce using rule 44 (continue_expr -> CONTINUE .)
    DIVIDE          reduce using rule 44 (continue_expr -> CONTINUE .)
    REMINDER        reduce using rule 44 (continue_expr -> CONTINUE .)
    AND             reduce using rule 44 (continue_expr -> CONTINUE .)
    OR              reduce using rule 44 (continue_expr -> CONTINUE .)
    XOR             reduce using rule 44 (continue_expr -> CONTINUE .)
    EQUALS          reduce using rule 44 (continue_expr -> CONTINUE .)
    NE              reduce using rule 44 (continue_expr -> CONTINUE .)
    LT              reduce using rule 44 (continue_expr -> CONTINUE .)
    GT              reduce using rule 44 (continue_expr -> CONTINUE .)
    LE              reduce using rule 44 (continue_expr -> CONTINUE .)
    GE              reduce using rule 44 (continue_expr -> CONTINUE .)
    RPAREN          reduce using rule 44 (continue_expr -> CONTINUE .)
    RBRACKET        reduce using rule 44 (continue_expr -> CONTINUE .)


state 38

    (45) if_expr -> IF . no_struct_literal_expr block_expr
    (46) if_expr -> IF . no_struct_literal_expr block_expr else_tail
    (51) no_struct_literal_expr -> . literal
    (52) no_struct_literal_expr -> . literal binop literal
    (53) no_struct_literal_expr -> . literal binop literal binop literal
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID

    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 76

    no_struct_literal_expr         shift and go to state 78
    literal                        shift and go to state 75
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29

state 39

    (49) return_expr -> RETURN .
    (50) return_expr -> RETURN . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    SEMICOLON       reduce using rule 49 (return_expr -> RETURN .)
    ASSIGN          reduce using rule 49 (return_expr -> RETURN .)
    PLUS            reduce using rule 49 (return_expr -> RETURN .)
    MINUS           reduce using rule 49 (return_expr -> RETURN .)
    MULT            reduce using rule 49 (return_expr -> RETURN .)
    DIVIDE          reduce using rule 49 (return_expr -> RETURN .)
    REMINDER        reduce using rule 49 (return_expr -> RETURN .)
    AND             reduce using rule 49 (return_expr -> RETURN .)
    OR              reduce using rule 49 (return_expr -> RETURN .)
    XOR             reduce using rule 49 (return_expr -> RETURN .)
    EQUALS          reduce using rule 49 (return_expr -> RETURN .)
    NE              reduce using rule 49 (return_expr -> RETURN .)
    LT              reduce using rule 49 (return_expr -> RETURN .)
    GT              reduce using rule 49 (return_expr -> RETURN .)
    LE              reduce using rule 49 (return_expr -> RETURN .)
    GE              reduce using rule 49 (return_expr -> RETURN .)
    RPAREN          reduce using rule 49 (return_expr -> RETURN .)
    RBRACKET        reduce using rule 49 (return_expr -> RETURN .)
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 79
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 40

    (58) num_lit -> INTEGER .

    SEMICOLON       reduce using rule 58 (num_lit -> INTEGER .)
    ASSIGN          reduce using rule 58 (num_lit -> INTEGER .)
    PLUS            reduce using rule 58 (num_lit -> INTEGER .)
    MINUS           reduce using rule 58 (num_lit -> INTEGER .)
    MULT            reduce using rule 58 (num_lit -> INTEGER .)
    DIVIDE          reduce using rule 58 (num_lit -> INTEGER .)
    REMINDER        reduce using rule 58 (num_lit -> INTEGER .)
    AND             reduce using rule 58 (num_lit -> INTEGER .)
    OR              reduce using rule 58 (num_lit -> INTEGER .)
    XOR             reduce using rule 58 (num_lit -> INTEGER .)
    EQUALS          reduce using rule 58 (num_lit -> INTEGER .)
    NE              reduce using rule 58 (num_lit -> INTEGER .)
    LT              reduce using rule 58 (num_lit -> INTEGER .)
    GT              reduce using rule 58 (num_lit -> INTEGER .)
    LE              reduce using rule 58 (num_lit -> INTEGER .)
    GE              reduce using rule 58 (num_lit -> INTEGER .)
    RPAREN          reduce using rule 58 (num_lit -> INTEGER .)
    RBRACKET        reduce using rule 58 (num_lit -> INTEGER .)
    LBRACKET        reduce using rule 58 (num_lit -> INTEGER .)


state 41

    (59) num_lit -> FLOAT .

    SEMICOLON       reduce using rule 59 (num_lit -> FLOAT .)
    ASSIGN          reduce using rule 59 (num_lit -> FLOAT .)
    PLUS            reduce using rule 59 (num_lit -> FLOAT .)
    MINUS           reduce using rule 59 (num_lit -> FLOAT .)
    MULT            reduce using rule 59 (num_lit -> FLOAT .)
    DIVIDE          reduce using rule 59 (num_lit -> FLOAT .)
    REMINDER        reduce using rule 59 (num_lit -> FLOAT .)
    AND             reduce using rule 59 (num_lit -> FLOAT .)
    OR              reduce using rule 59 (num_lit -> FLOAT .)
    XOR             reduce using rule 59 (num_lit -> FLOAT .)
    EQUALS          reduce using rule 59 (num_lit -> FLOAT .)
    NE              reduce using rule 59 (num_lit -> FLOAT .)
    LT              reduce using rule 59 (num_lit -> FLOAT .)
    GT              reduce using rule 59 (num_lit -> FLOAT .)
    LE              reduce using rule 59 (num_lit -> FLOAT .)
    GE              reduce using rule 59 (num_lit -> FLOAT .)
    RPAREN          reduce using rule 59 (num_lit -> FLOAT .)
    RBRACKET        reduce using rule 59 (num_lit -> FLOAT .)
    LBRACKET        reduce using rule 59 (num_lit -> FLOAT .)


state 42

    (60) bool_lit -> TRUE .

    SEMICOLON       reduce using rule 60 (bool_lit -> TRUE .)
    ASSIGN          reduce using rule 60 (bool_lit -> TRUE .)
    PLUS            reduce using rule 60 (bool_lit -> TRUE .)
    MINUS           reduce using rule 60 (bool_lit -> TRUE .)
    MULT            reduce using rule 60 (bool_lit -> TRUE .)
    DIVIDE          reduce using rule 60 (bool_lit -> TRUE .)
    REMINDER        reduce using rule 60 (bool_lit -> TRUE .)
    AND             reduce using rule 60 (bool_lit -> TRUE .)
    OR              reduce using rule 60 (bool_lit -> TRUE .)
    XOR             reduce using rule 60 (bool_lit -> TRUE .)
    EQUALS          reduce using rule 60 (bool_lit -> TRUE .)
    NE              reduce using rule 60 (bool_lit -> TRUE .)
    LT              reduce using rule 60 (bool_lit -> TRUE .)
    GT              reduce using rule 60 (bool_lit -> TRUE .)
    LE              reduce using rule 60 (bool_lit -> TRUE .)
    GE              reduce using rule 60 (bool_lit -> TRUE .)
    RPAREN          reduce using rule 60 (bool_lit -> TRUE .)
    RBRACKET        reduce using rule 60 (bool_lit -> TRUE .)
    LBRACKET        reduce using rule 60 (bool_lit -> TRUE .)


state 43

    (61) bool_lit -> FALSE .

    SEMICOLON       reduce using rule 61 (bool_lit -> FALSE .)
    ASSIGN          reduce using rule 61 (bool_lit -> FALSE .)
    PLUS            reduce using rule 61 (bool_lit -> FALSE .)
    MINUS           reduce using rule 61 (bool_lit -> FALSE .)
    MULT            reduce using rule 61 (bool_lit -> FALSE .)
    DIVIDE          reduce using rule 61 (bool_lit -> FALSE .)
    REMINDER        reduce using rule 61 (bool_lit -> FALSE .)
    AND             reduce using rule 61 (bool_lit -> FALSE .)
    OR              reduce using rule 61 (bool_lit -> FALSE .)
    XOR             reduce using rule 61 (bool_lit -> FALSE .)
    EQUALS          reduce using rule 61 (bool_lit -> FALSE .)
    NE              reduce using rule 61 (bool_lit -> FALSE .)
    LT              reduce using rule 61 (bool_lit -> FALSE .)
    GT              reduce using rule 61 (bool_lit -> FALSE .)
    LE              reduce using rule 61 (bool_lit -> FALSE .)
    GE              reduce using rule 61 (bool_lit -> FALSE .)
    RPAREN          reduce using rule 61 (bool_lit -> FALSE .)
    RBRACKET        reduce using rule 61 (bool_lit -> FALSE .)
    LBRACKET        reduce using rule 61 (bool_lit -> FALSE .)


state 44

    (6) expr_stmt -> expr SEMICOLON .

    $end            reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    LBRACKET        reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    LOOP            reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    BREAK           reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    CONTINUE        reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    IF              reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    INTEGER         reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    TRUE            reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    FALSE           reduce using rule 6 (expr_stmt -> expr SEMICOLON .)
    ID              reduce using rule 6 (expr_stmt -> expr SEMICOLON .)


state 45

    (36) binop_expr -> expr binop . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 80
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 46

    (80) assignment_expr -> expr ASSIGN . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 81
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 47

    (81) compound_assignment_expr -> expr arith_op . ASSIGN expr
    (62) binop -> arith_op .

    ASSIGN          shift and go to state 82
    LBRACKET        reduce using rule 62 (binop -> arith_op .)
    LPAREN          reduce using rule 62 (binop -> arith_op .)
    WHILE           reduce using rule 62 (binop -> arith_op .)
    LOOP            reduce using rule 62 (binop -> arith_op .)
    BREAK           reduce using rule 62 (binop -> arith_op .)
    CONTINUE        reduce using rule 62 (binop -> arith_op .)
    IF              reduce using rule 62 (binop -> arith_op .)
    RETURN          reduce using rule 62 (binop -> arith_op .)
    INTEGER         reduce using rule 62 (binop -> arith_op .)
    FLOAT           reduce using rule 62 (binop -> arith_op .)
    TRUE            reduce using rule 62 (binop -> arith_op .)
    FALSE           reduce using rule 62 (binop -> arith_op .)
    ID              reduce using rule 62 (binop -> arith_op .)


state 48

    (82) compound_assignment_expr -> expr bitwise_op . ASSIGN expr
    (63) binop -> bitwise_op .

    ASSIGN          shift and go to state 83
    LBRACKET        reduce using rule 63 (binop -> bitwise_op .)
    LPAREN          reduce using rule 63 (binop -> bitwise_op .)
    WHILE           reduce using rule 63 (binop -> bitwise_op .)
    LOOP            reduce using rule 63 (binop -> bitwise_op .)
    BREAK           reduce using rule 63 (binop -> bitwise_op .)
    CONTINUE        reduce using rule 63 (binop -> bitwise_op .)
    IF              reduce using rule 63 (binop -> bitwise_op .)
    RETURN          reduce using rule 63 (binop -> bitwise_op .)
    INTEGER         reduce using rule 63 (binop -> bitwise_op .)
    FLOAT           reduce using rule 63 (binop -> bitwise_op .)
    TRUE            reduce using rule 63 (binop -> bitwise_op .)
    FALSE           reduce using rule 63 (binop -> bitwise_op .)
    ID              reduce using rule 63 (binop -> bitwise_op .)


state 49

    (64) binop -> comp_op .

    LBRACKET        reduce using rule 64 (binop -> comp_op .)
    LPAREN          reduce using rule 64 (binop -> comp_op .)
    WHILE           reduce using rule 64 (binop -> comp_op .)
    LOOP            reduce using rule 64 (binop -> comp_op .)
    BREAK           reduce using rule 64 (binop -> comp_op .)
    CONTINUE        reduce using rule 64 (binop -> comp_op .)
    IF              reduce using rule 64 (binop -> comp_op .)
    RETURN          reduce using rule 64 (binop -> comp_op .)
    INTEGER         reduce using rule 64 (binop -> comp_op .)
    FLOAT           reduce using rule 64 (binop -> comp_op .)
    TRUE            reduce using rule 64 (binop -> comp_op .)
    FALSE           reduce using rule 64 (binop -> comp_op .)
    ID              reduce using rule 64 (binop -> comp_op .)


state 50

    (65) arith_op -> PLUS .

    ASSIGN          reduce using rule 65 (arith_op -> PLUS .)
    LBRACKET        reduce using rule 65 (arith_op -> PLUS .)
    LPAREN          reduce using rule 65 (arith_op -> PLUS .)
    WHILE           reduce using rule 65 (arith_op -> PLUS .)
    LOOP            reduce using rule 65 (arith_op -> PLUS .)
    BREAK           reduce using rule 65 (arith_op -> PLUS .)
    CONTINUE        reduce using rule 65 (arith_op -> PLUS .)
    IF              reduce using rule 65 (arith_op -> PLUS .)
    RETURN          reduce using rule 65 (arith_op -> PLUS .)
    INTEGER         reduce using rule 65 (arith_op -> PLUS .)
    FLOAT           reduce using rule 65 (arith_op -> PLUS .)
    TRUE            reduce using rule 65 (arith_op -> PLUS .)
    FALSE           reduce using rule 65 (arith_op -> PLUS .)
    ID              reduce using rule 65 (arith_op -> PLUS .)


state 51

    (66) arith_op -> MINUS .

    ASSIGN          reduce using rule 66 (arith_op -> MINUS .)
    LBRACKET        reduce using rule 66 (arith_op -> MINUS .)
    LPAREN          reduce using rule 66 (arith_op -> MINUS .)
    WHILE           reduce using rule 66 (arith_op -> MINUS .)
    LOOP            reduce using rule 66 (arith_op -> MINUS .)
    BREAK           reduce using rule 66 (arith_op -> MINUS .)
    CONTINUE        reduce using rule 66 (arith_op -> MINUS .)
    IF              reduce using rule 66 (arith_op -> MINUS .)
    RETURN          reduce using rule 66 (arith_op -> MINUS .)
    INTEGER         reduce using rule 66 (arith_op -> MINUS .)
    FLOAT           reduce using rule 66 (arith_op -> MINUS .)
    TRUE            reduce using rule 66 (arith_op -> MINUS .)
    FALSE           reduce using rule 66 (arith_op -> MINUS .)
    ID              reduce using rule 66 (arith_op -> MINUS .)


state 52

    (67) arith_op -> MULT .

    ASSIGN          reduce using rule 67 (arith_op -> MULT .)
    LBRACKET        reduce using rule 67 (arith_op -> MULT .)
    LPAREN          reduce using rule 67 (arith_op -> MULT .)
    WHILE           reduce using rule 67 (arith_op -> MULT .)
    LOOP            reduce using rule 67 (arith_op -> MULT .)
    BREAK           reduce using rule 67 (arith_op -> MULT .)
    CONTINUE        reduce using rule 67 (arith_op -> MULT .)
    IF              reduce using rule 67 (arith_op -> MULT .)
    RETURN          reduce using rule 67 (arith_op -> MULT .)
    INTEGER         reduce using rule 67 (arith_op -> MULT .)
    FLOAT           reduce using rule 67 (arith_op -> MULT .)
    TRUE            reduce using rule 67 (arith_op -> MULT .)
    FALSE           reduce using rule 67 (arith_op -> MULT .)
    ID              reduce using rule 67 (arith_op -> MULT .)


state 53

    (68) arith_op -> DIVIDE .

    ASSIGN          reduce using rule 68 (arith_op -> DIVIDE .)
    LBRACKET        reduce using rule 68 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 68 (arith_op -> DIVIDE .)
    WHILE           reduce using rule 68 (arith_op -> DIVIDE .)
    LOOP            reduce using rule 68 (arith_op -> DIVIDE .)
    BREAK           reduce using rule 68 (arith_op -> DIVIDE .)
    CONTINUE        reduce using rule 68 (arith_op -> DIVIDE .)
    IF              reduce using rule 68 (arith_op -> DIVIDE .)
    RETURN          reduce using rule 68 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 68 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 68 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 68 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 68 (arith_op -> DIVIDE .)
    ID              reduce using rule 68 (arith_op -> DIVIDE .)


state 54

    (69) arith_op -> REMINDER .

    ASSIGN          reduce using rule 69 (arith_op -> REMINDER .)
    LBRACKET        reduce using rule 69 (arith_op -> REMINDER .)
    LPAREN          reduce using rule 69 (arith_op -> REMINDER .)
    WHILE           reduce using rule 69 (arith_op -> REMINDER .)
    LOOP            reduce using rule 69 (arith_op -> REMINDER .)
    BREAK           reduce using rule 69 (arith_op -> REMINDER .)
    CONTINUE        reduce using rule 69 (arith_op -> REMINDER .)
    IF              reduce using rule 69 (arith_op -> REMINDER .)
    RETURN          reduce using rule 69 (arith_op -> REMINDER .)
    INTEGER         reduce using rule 69 (arith_op -> REMINDER .)
    FLOAT           reduce using rule 69 (arith_op -> REMINDER .)
    TRUE            reduce using rule 69 (arith_op -> REMINDER .)
    FALSE           reduce using rule 69 (arith_op -> REMINDER .)
    ID              reduce using rule 69 (arith_op -> REMINDER .)


state 55

    (70) bitwise_op -> AND .

    ASSIGN          reduce using rule 70 (bitwise_op -> AND .)
    LBRACKET        reduce using rule 70 (bitwise_op -> AND .)
    LPAREN          reduce using rule 70 (bitwise_op -> AND .)
    WHILE           reduce using rule 70 (bitwise_op -> AND .)
    LOOP            reduce using rule 70 (bitwise_op -> AND .)
    BREAK           reduce using rule 70 (bitwise_op -> AND .)
    CONTINUE        reduce using rule 70 (bitwise_op -> AND .)
    IF              reduce using rule 70 (bitwise_op -> AND .)
    RETURN          reduce using rule 70 (bitwise_op -> AND .)
    INTEGER         reduce using rule 70 (bitwise_op -> AND .)
    FLOAT           reduce using rule 70 (bitwise_op -> AND .)
    TRUE            reduce using rule 70 (bitwise_op -> AND .)
    FALSE           reduce using rule 70 (bitwise_op -> AND .)
    ID              reduce using rule 70 (bitwise_op -> AND .)


state 56

    (71) bitwise_op -> OR .

    ASSIGN          reduce using rule 71 (bitwise_op -> OR .)
    LBRACKET        reduce using rule 71 (bitwise_op -> OR .)
    LPAREN          reduce using rule 71 (bitwise_op -> OR .)
    WHILE           reduce using rule 71 (bitwise_op -> OR .)
    LOOP            reduce using rule 71 (bitwise_op -> OR .)
    BREAK           reduce using rule 71 (bitwise_op -> OR .)
    CONTINUE        reduce using rule 71 (bitwise_op -> OR .)
    IF              reduce using rule 71 (bitwise_op -> OR .)
    RETURN          reduce using rule 71 (bitwise_op -> OR .)
    INTEGER         reduce using rule 71 (bitwise_op -> OR .)
    FLOAT           reduce using rule 71 (bitwise_op -> OR .)
    TRUE            reduce using rule 71 (bitwise_op -> OR .)
    FALSE           reduce using rule 71 (bitwise_op -> OR .)
    ID              reduce using rule 71 (bitwise_op -> OR .)


state 57

    (72) bitwise_op -> XOR .

    ASSIGN          reduce using rule 72 (bitwise_op -> XOR .)
    LBRACKET        reduce using rule 72 (bitwise_op -> XOR .)
    LPAREN          reduce using rule 72 (bitwise_op -> XOR .)
    WHILE           reduce using rule 72 (bitwise_op -> XOR .)
    LOOP            reduce using rule 72 (bitwise_op -> XOR .)
    BREAK           reduce using rule 72 (bitwise_op -> XOR .)
    CONTINUE        reduce using rule 72 (bitwise_op -> XOR .)
    IF              reduce using rule 72 (bitwise_op -> XOR .)
    RETURN          reduce using rule 72 (bitwise_op -> XOR .)
    INTEGER         reduce using rule 72 (bitwise_op -> XOR .)
    FLOAT           reduce using rule 72 (bitwise_op -> XOR .)
    TRUE            reduce using rule 72 (bitwise_op -> XOR .)
    FALSE           reduce using rule 72 (bitwise_op -> XOR .)
    ID              reduce using rule 72 (bitwise_op -> XOR .)


state 58

    (73) comp_op -> EQUALS .

    LBRACKET        reduce using rule 73 (comp_op -> EQUALS .)
    LPAREN          reduce using rule 73 (comp_op -> EQUALS .)
    WHILE           reduce using rule 73 (comp_op -> EQUALS .)
    LOOP            reduce using rule 73 (comp_op -> EQUALS .)
    BREAK           reduce using rule 73 (comp_op -> EQUALS .)
    CONTINUE        reduce using rule 73 (comp_op -> EQUALS .)
    IF              reduce using rule 73 (comp_op -> EQUALS .)
    RETURN          reduce using rule 73 (comp_op -> EQUALS .)
    INTEGER         reduce using rule 73 (comp_op -> EQUALS .)
    FLOAT           reduce using rule 73 (comp_op -> EQUALS .)
    TRUE            reduce using rule 73 (comp_op -> EQUALS .)
    FALSE           reduce using rule 73 (comp_op -> EQUALS .)
    ID              reduce using rule 73 (comp_op -> EQUALS .)


state 59

    (74) comp_op -> NE .

    LBRACKET        reduce using rule 74 (comp_op -> NE .)
    LPAREN          reduce using rule 74 (comp_op -> NE .)
    WHILE           reduce using rule 74 (comp_op -> NE .)
    LOOP            reduce using rule 74 (comp_op -> NE .)
    BREAK           reduce using rule 74 (comp_op -> NE .)
    CONTINUE        reduce using rule 74 (comp_op -> NE .)
    IF              reduce using rule 74 (comp_op -> NE .)
    RETURN          reduce using rule 74 (comp_op -> NE .)
    INTEGER         reduce using rule 74 (comp_op -> NE .)
    FLOAT           reduce using rule 74 (comp_op -> NE .)
    TRUE            reduce using rule 74 (comp_op -> NE .)
    FALSE           reduce using rule 74 (comp_op -> NE .)
    ID              reduce using rule 74 (comp_op -> NE .)


state 60

    (75) comp_op -> LT .

    LBRACKET        reduce using rule 75 (comp_op -> LT .)
    LPAREN          reduce using rule 75 (comp_op -> LT .)
    WHILE           reduce using rule 75 (comp_op -> LT .)
    LOOP            reduce using rule 75 (comp_op -> LT .)
    BREAK           reduce using rule 75 (comp_op -> LT .)
    CONTINUE        reduce using rule 75 (comp_op -> LT .)
    IF              reduce using rule 75 (comp_op -> LT .)
    RETURN          reduce using rule 75 (comp_op -> LT .)
    INTEGER         reduce using rule 75 (comp_op -> LT .)
    FLOAT           reduce using rule 75 (comp_op -> LT .)
    TRUE            reduce using rule 75 (comp_op -> LT .)
    FALSE           reduce using rule 75 (comp_op -> LT .)
    ID              reduce using rule 75 (comp_op -> LT .)


state 61

    (76) comp_op -> GT .

    LBRACKET        reduce using rule 76 (comp_op -> GT .)
    LPAREN          reduce using rule 76 (comp_op -> GT .)
    WHILE           reduce using rule 76 (comp_op -> GT .)
    LOOP            reduce using rule 76 (comp_op -> GT .)
    BREAK           reduce using rule 76 (comp_op -> GT .)
    CONTINUE        reduce using rule 76 (comp_op -> GT .)
    IF              reduce using rule 76 (comp_op -> GT .)
    RETURN          reduce using rule 76 (comp_op -> GT .)
    INTEGER         reduce using rule 76 (comp_op -> GT .)
    FLOAT           reduce using rule 76 (comp_op -> GT .)
    TRUE            reduce using rule 76 (comp_op -> GT .)
    FALSE           reduce using rule 76 (comp_op -> GT .)
    ID              reduce using rule 76 (comp_op -> GT .)


state 62

    (77) comp_op -> LE .

    LBRACKET        reduce using rule 77 (comp_op -> LE .)
    LPAREN          reduce using rule 77 (comp_op -> LE .)
    WHILE           reduce using rule 77 (comp_op -> LE .)
    LOOP            reduce using rule 77 (comp_op -> LE .)
    BREAK           reduce using rule 77 (comp_op -> LE .)
    CONTINUE        reduce using rule 77 (comp_op -> LE .)
    IF              reduce using rule 77 (comp_op -> LE .)
    RETURN          reduce using rule 77 (comp_op -> LE .)
    INTEGER         reduce using rule 77 (comp_op -> LE .)
    FLOAT           reduce using rule 77 (comp_op -> LE .)
    TRUE            reduce using rule 77 (comp_op -> LE .)
    FALSE           reduce using rule 77 (comp_op -> LE .)
    ID              reduce using rule 77 (comp_op -> LE .)


state 63

    (78) comp_op -> GE .

    LBRACKET        reduce using rule 78 (comp_op -> GE .)
    LPAREN          reduce using rule 78 (comp_op -> GE .)
    WHILE           reduce using rule 78 (comp_op -> GE .)
    LOOP            reduce using rule 78 (comp_op -> GE .)
    BREAK           reduce using rule 78 (comp_op -> GE .)
    CONTINUE        reduce using rule 78 (comp_op -> GE .)
    IF              reduce using rule 78 (comp_op -> GE .)
    RETURN          reduce using rule 78 (comp_op -> GE .)
    INTEGER         reduce using rule 78 (comp_op -> GE .)
    FLOAT           reduce using rule 78 (comp_op -> GE .)
    TRUE            reduce using rule 78 (comp_op -> GE .)
    FALSE           reduce using rule 78 (comp_op -> GE .)
    ID              reduce using rule 78 (comp_op -> GE .)


state 64

    (13) let_decl -> LET MUT . ID COLON type init SEMICOLON
    (14) let_decl -> LET MUT . ID COLON type SEMICOLON
    (15) let_decl -> LET MUT . ID init SEMICOLON
    (16) let_decl -> LET MUT . ID SEMICOLON

    ID              shift and go to state 84


state 65

    (17) let_decl -> LET ID . COLON type init SEMICOLON
    (18) let_decl -> LET ID . COLON type SEMICOLON
    (19) let_decl -> LET ID . init SEMICOLON
    (20) let_decl -> LET ID . SEMICOLON
    (21) init -> . ASSIGN expr
    (22) init -> . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    COLON           shift and go to state 85
    SEMICOLON       shift and go to state 87
    ASSIGN          shift and go to state 88
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    init                           shift and go to state 86
    expr                           shift and go to state 89
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 66

    (79) type_cast_expr -> ID AS . type
    (83) type -> . SIGNINTTYPE
    (84) type -> . UNSIGNINTTYPE
    (85) type -> . FLOATTYPE
    (86) type -> . BOOLTYPE
    (87) type -> . CHARTYPE

    SIGNINTTYPE     shift and go to state 91
    UNSIGNINTTYPE   shift and go to state 92
    FLOATTYPE       shift and go to state 93
    BOOLTYPE        shift and go to state 94
    CHARTYPE        shift and go to state 95

    type                           shift and go to state 90

state 67

    (10) fn_item -> FN ID . LPAREN RPAREN block_expr

    LPAREN          shift and go to state 96


state 68

    (40) paren_expr -> LPAREN expr . RPAREN
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    RPAREN          shift and go to state 97
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 69

    (11) const_item -> CONST ID . COLON type ASSIGN expr SEMICOLON

    COLON           shift and go to state 98


state 70

    (12) static_item -> STATIC ID . COLON type ASSIGN expr SEMICOLON

    COLON           shift and go to state 99


state 71

    (33) block_expr -> LBRACKET stmt . expr RBRACKET
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 100
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 72

    (35) block_expr -> LBRACKET expr . RBRACKET
    (6) expr_stmt -> expr . SEMICOLON
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    RBRACKET        shift and go to state 101
    SEMICOLON       shift and go to state 44
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 73

    (34) block_expr -> LBRACKET item . expr RBRACKET
    (4) decl_stmt -> item .
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

  ! LBRACKET        [ reduce using rule 4 (decl_stmt -> item .) ]
  ! LPAREN          [ reduce using rule 4 (decl_stmt -> item .) ]
  ! WHILE           [ reduce using rule 4 (decl_stmt -> item .) ]
  ! LOOP            [ reduce using rule 4 (decl_stmt -> item .) ]
  ! BREAK           [ reduce using rule 4 (decl_stmt -> item .) ]
  ! CONTINUE        [ reduce using rule 4 (decl_stmt -> item .) ]
  ! IF              [ reduce using rule 4 (decl_stmt -> item .) ]
  ! RETURN          [ reduce using rule 4 (decl_stmt -> item .) ]
  ! INTEGER         [ reduce using rule 4 (decl_stmt -> item .) ]
  ! FLOAT           [ reduce using rule 4 (decl_stmt -> item .) ]
  ! TRUE            [ reduce using rule 4 (decl_stmt -> item .) ]
  ! FALSE           [ reduce using rule 4 (decl_stmt -> item .) ]
  ! ID              [ reduce using rule 4 (decl_stmt -> item .) ]

    expr                           shift and go to state 102
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 74

    (41) while_expr -> WHILE no_struct_literal_expr . block_expr
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 30

    block_expr                     shift and go to state 103

state 75

    (51) no_struct_literal_expr -> literal .
    (52) no_struct_literal_expr -> literal . binop literal
    (53) no_struct_literal_expr -> literal . binop literal binop literal
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    LBRACKET        reduce using rule 51 (no_struct_literal_expr -> literal .)
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 104
    arith_op                       shift and go to state 105
    bitwise_op                     shift and go to state 106
    comp_op                        shift and go to state 49

state 76

    (54) lit_suffix -> ID .

    PLUS            reduce using rule 54 (lit_suffix -> ID .)
    MINUS           reduce using rule 54 (lit_suffix -> ID .)
    MULT            reduce using rule 54 (lit_suffix -> ID .)
    DIVIDE          reduce using rule 54 (lit_suffix -> ID .)
    REMINDER        reduce using rule 54 (lit_suffix -> ID .)
    AND             reduce using rule 54 (lit_suffix -> ID .)
    OR              reduce using rule 54 (lit_suffix -> ID .)
    XOR             reduce using rule 54 (lit_suffix -> ID .)
    EQUALS          reduce using rule 54 (lit_suffix -> ID .)
    NE              reduce using rule 54 (lit_suffix -> ID .)
    LT              reduce using rule 54 (lit_suffix -> ID .)
    GT              reduce using rule 54 (lit_suffix -> ID .)
    LE              reduce using rule 54 (lit_suffix -> ID .)
    GE              reduce using rule 54 (lit_suffix -> ID .)
    LBRACKET        reduce using rule 54 (lit_suffix -> ID .)


state 77

    (42) loop_expr -> LOOP block_expr .

    SEMICOLON       reduce using rule 42 (loop_expr -> LOOP block_expr .)
    ASSIGN          reduce using rule 42 (loop_expr -> LOOP block_expr .)
    PLUS            reduce using rule 42 (loop_expr -> LOOP block_expr .)
    MINUS           reduce using rule 42 (loop_expr -> LOOP block_expr .)
    MULT            reduce using rule 42 (loop_expr -> LOOP block_expr .)
    DIVIDE          reduce using rule 42 (loop_expr -> LOOP block_expr .)
    REMINDER        reduce using rule 42 (loop_expr -> LOOP block_expr .)
    AND             reduce using rule 42 (loop_expr -> LOOP block_expr .)
    OR              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    XOR             reduce using rule 42 (loop_expr -> LOOP block_expr .)
    EQUALS          reduce using rule 42 (loop_expr -> LOOP block_expr .)
    NE              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    LT              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    GT              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    LE              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    GE              reduce using rule 42 (loop_expr -> LOOP block_expr .)
    RPAREN          reduce using rule 42 (loop_expr -> LOOP block_expr .)
    RBRACKET        reduce using rule 42 (loop_expr -> LOOP block_expr .)


state 78

    (45) if_expr -> IF no_struct_literal_expr . block_expr
    (46) if_expr -> IF no_struct_literal_expr . block_expr else_tail
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 30

    block_expr                     shift and go to state 107

state 79

    (50) return_expr -> RETURN expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMINDER resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMICOLON       reduce using rule 50 (return_expr -> RETURN expr .)
    RPAREN          reduce using rule 50 (return_expr -> RETURN expr .)
    RBRACKET        reduce using rule 50 (return_expr -> RETURN expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! ASSIGN          [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! PLUS            [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! MINUS           [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! MULT            [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! DIVIDE          [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! REMINDER        [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! AND             [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! OR              [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! XOR             [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! EQUALS          [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! NE              [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! LT              [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! GT              [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! LE              [ reduce using rule 50 (return_expr -> RETURN expr .) ]
  ! GE              [ reduce using rule 50 (return_expr -> RETURN expr .) ]

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 80

    (36) binop_expr -> expr binop expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMINDER resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMICOLON       reduce using rule 36 (binop_expr -> expr binop expr .)
    RPAREN          reduce using rule 36 (binop_expr -> expr binop expr .)
    RBRACKET        reduce using rule 36 (binop_expr -> expr binop expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! ASSIGN          [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! PLUS            [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! MINUS           [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! MULT            [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! DIVIDE          [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! REMINDER        [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! AND             [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! OR              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! XOR             [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! EQUALS          [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! NE              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! LT              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! GT              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! LE              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]
  ! GE              [ reduce using rule 36 (binop_expr -> expr binop expr .) ]

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 81

    (80) assignment_expr -> expr ASSIGN expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMINDER resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMICOLON       reduce using rule 80 (assignment_expr -> expr ASSIGN expr .)
    RPAREN          reduce using rule 80 (assignment_expr -> expr ASSIGN expr .)
    RBRACKET        reduce using rule 80 (assignment_expr -> expr ASSIGN expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! ASSIGN          [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! MULT            [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! REMINDER        [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! AND             [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! OR              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! XOR             [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! EQUALS          [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! NE              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! LT              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! GT              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! LE              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]
  ! GE              [ reduce using rule 80 (assignment_expr -> expr ASSIGN expr .) ]

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 82

    (81) compound_assignment_expr -> expr arith_op ASSIGN . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 108
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 83

    (82) compound_assignment_expr -> expr bitwise_op ASSIGN . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 109
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 84

    (13) let_decl -> LET MUT ID . COLON type init SEMICOLON
    (14) let_decl -> LET MUT ID . COLON type SEMICOLON
    (15) let_decl -> LET MUT ID . init SEMICOLON
    (16) let_decl -> LET MUT ID . SEMICOLON
    (21) init -> . ASSIGN expr
    (22) init -> . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    COLON           shift and go to state 110
    SEMICOLON       shift and go to state 112
    ASSIGN          shift and go to state 88
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    init                           shift and go to state 111
    expr                           shift and go to state 89
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 85

    (17) let_decl -> LET ID COLON . type init SEMICOLON
    (18) let_decl -> LET ID COLON . type SEMICOLON
    (83) type -> . SIGNINTTYPE
    (84) type -> . UNSIGNINTTYPE
    (85) type -> . FLOATTYPE
    (86) type -> . BOOLTYPE
    (87) type -> . CHARTYPE

    SIGNINTTYPE     shift and go to state 91
    UNSIGNINTTYPE   shift and go to state 92
    FLOATTYPE       shift and go to state 93
    BOOLTYPE        shift and go to state 94
    CHARTYPE        shift and go to state 95

    type                           shift and go to state 113

state 86

    (19) let_decl -> LET ID init . SEMICOLON

    SEMICOLON       shift and go to state 114


state 87

    (20) let_decl -> LET ID SEMICOLON .

    $end            reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    LBRACKET        reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    LPAREN          reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    WHILE           reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    LOOP            reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    BREAK           reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    CONTINUE        reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    IF              reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    RETURN          reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    INTEGER         reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    FLOAT           reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    TRUE            reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    FALSE           reduce using rule 20 (let_decl -> LET ID SEMICOLON .)
    ID              reduce using rule 20 (let_decl -> LET ID SEMICOLON .)


state 88

    (21) init -> ASSIGN . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 115
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 89

    (22) init -> expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    SEMICOLON       reduce using rule 22 (init -> expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 90

    (79) type_cast_expr -> ID AS type .

    SEMICOLON       reduce using rule 79 (type_cast_expr -> ID AS type .)
    ASSIGN          reduce using rule 79 (type_cast_expr -> ID AS type .)
    PLUS            reduce using rule 79 (type_cast_expr -> ID AS type .)
    MINUS           reduce using rule 79 (type_cast_expr -> ID AS type .)
    MULT            reduce using rule 79 (type_cast_expr -> ID AS type .)
    DIVIDE          reduce using rule 79 (type_cast_expr -> ID AS type .)
    REMINDER        reduce using rule 79 (type_cast_expr -> ID AS type .)
    AND             reduce using rule 79 (type_cast_expr -> ID AS type .)
    OR              reduce using rule 79 (type_cast_expr -> ID AS type .)
    XOR             reduce using rule 79 (type_cast_expr -> ID AS type .)
    EQUALS          reduce using rule 79 (type_cast_expr -> ID AS type .)
    NE              reduce using rule 79 (type_cast_expr -> ID AS type .)
    LT              reduce using rule 79 (type_cast_expr -> ID AS type .)
    GT              reduce using rule 79 (type_cast_expr -> ID AS type .)
    LE              reduce using rule 79 (type_cast_expr -> ID AS type .)
    GE              reduce using rule 79 (type_cast_expr -> ID AS type .)
    RPAREN          reduce using rule 79 (type_cast_expr -> ID AS type .)
    RBRACKET        reduce using rule 79 (type_cast_expr -> ID AS type .)


state 91

    (83) type -> SIGNINTTYPE .

    SEMICOLON       reduce using rule 83 (type -> SIGNINTTYPE .)
    ASSIGN          reduce using rule 83 (type -> SIGNINTTYPE .)
    PLUS            reduce using rule 83 (type -> SIGNINTTYPE .)
    MINUS           reduce using rule 83 (type -> SIGNINTTYPE .)
    MULT            reduce using rule 83 (type -> SIGNINTTYPE .)
    DIVIDE          reduce using rule 83 (type -> SIGNINTTYPE .)
    REMINDER        reduce using rule 83 (type -> SIGNINTTYPE .)
    AND             reduce using rule 83 (type -> SIGNINTTYPE .)
    OR              reduce using rule 83 (type -> SIGNINTTYPE .)
    XOR             reduce using rule 83 (type -> SIGNINTTYPE .)
    EQUALS          reduce using rule 83 (type -> SIGNINTTYPE .)
    NE              reduce using rule 83 (type -> SIGNINTTYPE .)
    LT              reduce using rule 83 (type -> SIGNINTTYPE .)
    GT              reduce using rule 83 (type -> SIGNINTTYPE .)
    LE              reduce using rule 83 (type -> SIGNINTTYPE .)
    GE              reduce using rule 83 (type -> SIGNINTTYPE .)
    RPAREN          reduce using rule 83 (type -> SIGNINTTYPE .)
    RBRACKET        reduce using rule 83 (type -> SIGNINTTYPE .)
    LBRACKET        reduce using rule 83 (type -> SIGNINTTYPE .)
    LPAREN          reduce using rule 83 (type -> SIGNINTTYPE .)
    WHILE           reduce using rule 83 (type -> SIGNINTTYPE .)
    LOOP            reduce using rule 83 (type -> SIGNINTTYPE .)
    BREAK           reduce using rule 83 (type -> SIGNINTTYPE .)
    CONTINUE        reduce using rule 83 (type -> SIGNINTTYPE .)
    IF              reduce using rule 83 (type -> SIGNINTTYPE .)
    RETURN          reduce using rule 83 (type -> SIGNINTTYPE .)
    INTEGER         reduce using rule 83 (type -> SIGNINTTYPE .)
    FLOAT           reduce using rule 83 (type -> SIGNINTTYPE .)
    TRUE            reduce using rule 83 (type -> SIGNINTTYPE .)
    FALSE           reduce using rule 83 (type -> SIGNINTTYPE .)
    ID              reduce using rule 83 (type -> SIGNINTTYPE .)


state 92

    (84) type -> UNSIGNINTTYPE .

    SEMICOLON       reduce using rule 84 (type -> UNSIGNINTTYPE .)
    ASSIGN          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    PLUS            reduce using rule 84 (type -> UNSIGNINTTYPE .)
    MINUS           reduce using rule 84 (type -> UNSIGNINTTYPE .)
    MULT            reduce using rule 84 (type -> UNSIGNINTTYPE .)
    DIVIDE          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    REMINDER        reduce using rule 84 (type -> UNSIGNINTTYPE .)
    AND             reduce using rule 84 (type -> UNSIGNINTTYPE .)
    OR              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    XOR             reduce using rule 84 (type -> UNSIGNINTTYPE .)
    EQUALS          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    NE              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    LT              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    GT              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    LE              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    GE              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    RPAREN          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    RBRACKET        reduce using rule 84 (type -> UNSIGNINTTYPE .)
    LBRACKET        reduce using rule 84 (type -> UNSIGNINTTYPE .)
    LPAREN          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    WHILE           reduce using rule 84 (type -> UNSIGNINTTYPE .)
    LOOP            reduce using rule 84 (type -> UNSIGNINTTYPE .)
    BREAK           reduce using rule 84 (type -> UNSIGNINTTYPE .)
    CONTINUE        reduce using rule 84 (type -> UNSIGNINTTYPE .)
    IF              reduce using rule 84 (type -> UNSIGNINTTYPE .)
    RETURN          reduce using rule 84 (type -> UNSIGNINTTYPE .)
    INTEGER         reduce using rule 84 (type -> UNSIGNINTTYPE .)
    FLOAT           reduce using rule 84 (type -> UNSIGNINTTYPE .)
    TRUE            reduce using rule 84 (type -> UNSIGNINTTYPE .)
    FALSE           reduce using rule 84 (type -> UNSIGNINTTYPE .)
    ID              reduce using rule 84 (type -> UNSIGNINTTYPE .)


state 93

    (85) type -> FLOATTYPE .

    SEMICOLON       reduce using rule 85 (type -> FLOATTYPE .)
    ASSIGN          reduce using rule 85 (type -> FLOATTYPE .)
    PLUS            reduce using rule 85 (type -> FLOATTYPE .)
    MINUS           reduce using rule 85 (type -> FLOATTYPE .)
    MULT            reduce using rule 85 (type -> FLOATTYPE .)
    DIVIDE          reduce using rule 85 (type -> FLOATTYPE .)
    REMINDER        reduce using rule 85 (type -> FLOATTYPE .)
    AND             reduce using rule 85 (type -> FLOATTYPE .)
    OR              reduce using rule 85 (type -> FLOATTYPE .)
    XOR             reduce using rule 85 (type -> FLOATTYPE .)
    EQUALS          reduce using rule 85 (type -> FLOATTYPE .)
    NE              reduce using rule 85 (type -> FLOATTYPE .)
    LT              reduce using rule 85 (type -> FLOATTYPE .)
    GT              reduce using rule 85 (type -> FLOATTYPE .)
    LE              reduce using rule 85 (type -> FLOATTYPE .)
    GE              reduce using rule 85 (type -> FLOATTYPE .)
    RPAREN          reduce using rule 85 (type -> FLOATTYPE .)
    RBRACKET        reduce using rule 85 (type -> FLOATTYPE .)
    LBRACKET        reduce using rule 85 (type -> FLOATTYPE .)
    LPAREN          reduce using rule 85 (type -> FLOATTYPE .)
    WHILE           reduce using rule 85 (type -> FLOATTYPE .)
    LOOP            reduce using rule 85 (type -> FLOATTYPE .)
    BREAK           reduce using rule 85 (type -> FLOATTYPE .)
    CONTINUE        reduce using rule 85 (type -> FLOATTYPE .)
    IF              reduce using rule 85 (type -> FLOATTYPE .)
    RETURN          reduce using rule 85 (type -> FLOATTYPE .)
    INTEGER         reduce using rule 85 (type -> FLOATTYPE .)
    FLOAT           reduce using rule 85 (type -> FLOATTYPE .)
    TRUE            reduce using rule 85 (type -> FLOATTYPE .)
    FALSE           reduce using rule 85 (type -> FLOATTYPE .)
    ID              reduce using rule 85 (type -> FLOATTYPE .)


state 94

    (86) type -> BOOLTYPE .

    SEMICOLON       reduce using rule 86 (type -> BOOLTYPE .)
    ASSIGN          reduce using rule 86 (type -> BOOLTYPE .)
    PLUS            reduce using rule 86 (type -> BOOLTYPE .)
    MINUS           reduce using rule 86 (type -> BOOLTYPE .)
    MULT            reduce using rule 86 (type -> BOOLTYPE .)
    DIVIDE          reduce using rule 86 (type -> BOOLTYPE .)
    REMINDER        reduce using rule 86 (type -> BOOLTYPE .)
    AND             reduce using rule 86 (type -> BOOLTYPE .)
    OR              reduce using rule 86 (type -> BOOLTYPE .)
    XOR             reduce using rule 86 (type -> BOOLTYPE .)
    EQUALS          reduce using rule 86 (type -> BOOLTYPE .)
    NE              reduce using rule 86 (type -> BOOLTYPE .)
    LT              reduce using rule 86 (type -> BOOLTYPE .)
    GT              reduce using rule 86 (type -> BOOLTYPE .)
    LE              reduce using rule 86 (type -> BOOLTYPE .)
    GE              reduce using rule 86 (type -> BOOLTYPE .)
    RPAREN          reduce using rule 86 (type -> BOOLTYPE .)
    RBRACKET        reduce using rule 86 (type -> BOOLTYPE .)
    LBRACKET        reduce using rule 86 (type -> BOOLTYPE .)
    LPAREN          reduce using rule 86 (type -> BOOLTYPE .)
    WHILE           reduce using rule 86 (type -> BOOLTYPE .)
    LOOP            reduce using rule 86 (type -> BOOLTYPE .)
    BREAK           reduce using rule 86 (type -> BOOLTYPE .)
    CONTINUE        reduce using rule 86 (type -> BOOLTYPE .)
    IF              reduce using rule 86 (type -> BOOLTYPE .)
    RETURN          reduce using rule 86 (type -> BOOLTYPE .)
    INTEGER         reduce using rule 86 (type -> BOOLTYPE .)
    FLOAT           reduce using rule 86 (type -> BOOLTYPE .)
    TRUE            reduce using rule 86 (type -> BOOLTYPE .)
    FALSE           reduce using rule 86 (type -> BOOLTYPE .)
    ID              reduce using rule 86 (type -> BOOLTYPE .)


state 95

    (87) type -> CHARTYPE .

    SEMICOLON       reduce using rule 87 (type -> CHARTYPE .)
    ASSIGN          reduce using rule 87 (type -> CHARTYPE .)
    PLUS            reduce using rule 87 (type -> CHARTYPE .)
    MINUS           reduce using rule 87 (type -> CHARTYPE .)
    MULT            reduce using rule 87 (type -> CHARTYPE .)
    DIVIDE          reduce using rule 87 (type -> CHARTYPE .)
    REMINDER        reduce using rule 87 (type -> CHARTYPE .)
    AND             reduce using rule 87 (type -> CHARTYPE .)
    OR              reduce using rule 87 (type -> CHARTYPE .)
    XOR             reduce using rule 87 (type -> CHARTYPE .)
    EQUALS          reduce using rule 87 (type -> CHARTYPE .)
    NE              reduce using rule 87 (type -> CHARTYPE .)
    LT              reduce using rule 87 (type -> CHARTYPE .)
    GT              reduce using rule 87 (type -> CHARTYPE .)
    LE              reduce using rule 87 (type -> CHARTYPE .)
    GE              reduce using rule 87 (type -> CHARTYPE .)
    RPAREN          reduce using rule 87 (type -> CHARTYPE .)
    RBRACKET        reduce using rule 87 (type -> CHARTYPE .)
    LBRACKET        reduce using rule 87 (type -> CHARTYPE .)
    LPAREN          reduce using rule 87 (type -> CHARTYPE .)
    WHILE           reduce using rule 87 (type -> CHARTYPE .)
    LOOP            reduce using rule 87 (type -> CHARTYPE .)
    BREAK           reduce using rule 87 (type -> CHARTYPE .)
    CONTINUE        reduce using rule 87 (type -> CHARTYPE .)
    IF              reduce using rule 87 (type -> CHARTYPE .)
    RETURN          reduce using rule 87 (type -> CHARTYPE .)
    INTEGER         reduce using rule 87 (type -> CHARTYPE .)
    FLOAT           reduce using rule 87 (type -> CHARTYPE .)
    TRUE            reduce using rule 87 (type -> CHARTYPE .)
    FALSE           reduce using rule 87 (type -> CHARTYPE .)
    ID              reduce using rule 87 (type -> CHARTYPE .)


state 96

    (10) fn_item -> FN ID LPAREN . RPAREN block_expr

    RPAREN          shift and go to state 116


state 97

    (40) paren_expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    ASSIGN          reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    REMINDER        reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    XOR             reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    EQUALS          reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 40 (paren_expr -> LPAREN expr RPAREN .)


state 98

    (11) const_item -> CONST ID COLON . type ASSIGN expr SEMICOLON
    (83) type -> . SIGNINTTYPE
    (84) type -> . UNSIGNINTTYPE
    (85) type -> . FLOATTYPE
    (86) type -> . BOOLTYPE
    (87) type -> . CHARTYPE

    SIGNINTTYPE     shift and go to state 91
    UNSIGNINTTYPE   shift and go to state 92
    FLOATTYPE       shift and go to state 93
    BOOLTYPE        shift and go to state 94
    CHARTYPE        shift and go to state 95

    type                           shift and go to state 117

state 99

    (12) static_item -> STATIC ID COLON . type ASSIGN expr SEMICOLON
    (83) type -> . SIGNINTTYPE
    (84) type -> . UNSIGNINTTYPE
    (85) type -> . FLOATTYPE
    (86) type -> . BOOLTYPE
    (87) type -> . CHARTYPE

    SIGNINTTYPE     shift and go to state 91
    UNSIGNINTTYPE   shift and go to state 92
    FLOATTYPE       shift and go to state 93
    BOOLTYPE        shift and go to state 94
    CHARTYPE        shift and go to state 95

    type                           shift and go to state 118

state 100

    (33) block_expr -> LBRACKET stmt expr . RBRACKET
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    RBRACKET        shift and go to state 119
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 101

    (35) block_expr -> LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    ASSIGN          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    MULT            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    REMINDER        reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    XOR             reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    EQUALS          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    NE              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    LE              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    GE              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    ELSE            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    $end            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    WHILE           reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    LOOP            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    BREAK           reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    CONTINUE        reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    IF              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    RETURN          reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    INTEGER         reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    FLOAT           reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    TRUE            reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    FALSE           reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)
    ID              reduce using rule 35 (block_expr -> LBRACKET expr RBRACKET .)


state 102

    (34) block_expr -> LBRACKET item expr . RBRACKET
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    RBRACKET        shift and go to state 120
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 103

    (41) while_expr -> WHILE no_struct_literal_expr block_expr .

    SEMICOLON       reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    ASSIGN          reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    PLUS            reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    MINUS           reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    MULT            reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    DIVIDE          reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    REMINDER        reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    AND             reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    OR              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    XOR             reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    EQUALS          reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    NE              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    LT              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    GT              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    LE              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    GE              reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    RPAREN          reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)
    RBRACKET        reduce using rule 41 (while_expr -> WHILE no_struct_literal_expr block_expr .)


state 104

    (52) no_struct_literal_expr -> literal binop . literal
    (53) no_struct_literal_expr -> literal binop . literal binop literal
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID

    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 76

    literal                        shift and go to state 121
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29

state 105

    (62) binop -> arith_op .

    INTEGER         reduce using rule 62 (binop -> arith_op .)
    FLOAT           reduce using rule 62 (binop -> arith_op .)
    TRUE            reduce using rule 62 (binop -> arith_op .)
    FALSE           reduce using rule 62 (binop -> arith_op .)
    ID              reduce using rule 62 (binop -> arith_op .)


state 106

    (63) binop -> bitwise_op .

    INTEGER         reduce using rule 63 (binop -> bitwise_op .)
    FLOAT           reduce using rule 63 (binop -> bitwise_op .)
    TRUE            reduce using rule 63 (binop -> bitwise_op .)
    FALSE           reduce using rule 63 (binop -> bitwise_op .)
    ID              reduce using rule 63 (binop -> bitwise_op .)


state 107

    (45) if_expr -> IF no_struct_literal_expr block_expr .
    (46) if_expr -> IF no_struct_literal_expr block_expr . else_tail
    (47) else_tail -> . ELSE if_expr
    (48) else_tail -> . ELSE block_expr

    SEMICOLON       reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    ASSIGN          reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    PLUS            reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    MINUS           reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    MULT            reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    DIVIDE          reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    REMINDER        reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    AND             reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    OR              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    XOR             reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    EQUALS          reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    NE              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    LT              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    GT              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    LE              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    GE              reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    RPAREN          reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    RBRACKET        reduce using rule 45 (if_expr -> IF no_struct_literal_expr block_expr .)
    ELSE            shift and go to state 123

    else_tail                      shift and go to state 122

state 108

    (81) compound_assignment_expr -> expr arith_op ASSIGN expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMINDER resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMICOLON       reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .)
    RPAREN          reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .)
    RBRACKET        reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! ASSIGN          [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! MULT            [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! REMINDER        [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! AND             [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! OR              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! XOR             [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! EQUALS          [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! NE              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! LT              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! GT              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! LE              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]
  ! GE              [ reduce using rule 81 (compound_assignment_expr -> expr arith_op ASSIGN expr .) ]

    arith_op                       shift and go to state 47
    binop                          shift and go to state 45
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 109

    (82) compound_assignment_expr -> expr bitwise_op ASSIGN expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMINDER resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    SEMICOLON       reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .)
    RPAREN          reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .)
    RBRACKET        reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

  ! ASSIGN          [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! PLUS            [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! MULT            [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! REMINDER        [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! AND             [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! OR              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! XOR             [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! EQUALS          [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! NE              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! LT              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! GT              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! LE              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]
  ! GE              [ reduce using rule 82 (compound_assignment_expr -> expr bitwise_op ASSIGN expr .) ]

    bitwise_op                     shift and go to state 48
    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    comp_op                        shift and go to state 49

state 110

    (13) let_decl -> LET MUT ID COLON . type init SEMICOLON
    (14) let_decl -> LET MUT ID COLON . type SEMICOLON
    (83) type -> . SIGNINTTYPE
    (84) type -> . UNSIGNINTTYPE
    (85) type -> . FLOATTYPE
    (86) type -> . BOOLTYPE
    (87) type -> . CHARTYPE

    SIGNINTTYPE     shift and go to state 91
    UNSIGNINTTYPE   shift and go to state 92
    FLOATTYPE       shift and go to state 93
    BOOLTYPE        shift and go to state 94
    CHARTYPE        shift and go to state 95

    type                           shift and go to state 124

state 111

    (15) let_decl -> LET MUT ID init . SEMICOLON

    SEMICOLON       shift and go to state 125


state 112

    (16) let_decl -> LET MUT ID SEMICOLON .

    $end            reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    LBRACKET        reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    LPAREN          reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    WHILE           reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    LOOP            reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    BREAK           reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    CONTINUE        reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    IF              reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    RETURN          reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    INTEGER         reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    FLOAT           reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    TRUE            reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    FALSE           reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)
    ID              reduce using rule 16 (let_decl -> LET MUT ID SEMICOLON .)


state 113

    (17) let_decl -> LET ID COLON type . init SEMICOLON
    (18) let_decl -> LET ID COLON type . SEMICOLON
    (21) init -> . ASSIGN expr
    (22) init -> . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    SEMICOLON       shift and go to state 127
    ASSIGN          shift and go to state 88
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    init                           shift and go to state 126
    expr                           shift and go to state 89
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 114

    (19) let_decl -> LET ID init SEMICOLON .

    $end            reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    LBRACKET        reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    LPAREN          reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    WHILE           reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    LOOP            reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    BREAK           reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    CONTINUE        reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    IF              reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    RETURN          reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    INTEGER         reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    FLOAT           reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    TRUE            reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    FALSE           reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)
    ID              reduce using rule 19 (let_decl -> LET ID init SEMICOLON .)


state 115

    (21) init -> ASSIGN expr .
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    SEMICOLON       reduce using rule 21 (init -> ASSIGN expr .)
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 116

    (10) fn_item -> FN ID LPAREN RPAREN . block_expr
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 30

    block_expr                     shift and go to state 128

state 117

    (11) const_item -> CONST ID COLON type . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 129


state 118

    (12) static_item -> STATIC ID COLON type . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 130


state 119

    (33) block_expr -> LBRACKET stmt expr RBRACKET .

    SEMICOLON       reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    ASSIGN          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    PLUS            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    MINUS           reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    MULT            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    DIVIDE          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    REMINDER        reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    AND             reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    OR              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    XOR             reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    EQUALS          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    NE              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    LT              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    GT              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    LE              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    GE              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    RPAREN          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    RBRACKET        reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    ELSE            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    $end            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    LBRACKET        reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    LPAREN          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    WHILE           reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    LOOP            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    BREAK           reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    CONTINUE        reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    IF              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    RETURN          reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    INTEGER         reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    FLOAT           reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    TRUE            reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    FALSE           reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)
    ID              reduce using rule 33 (block_expr -> LBRACKET stmt expr RBRACKET .)


state 120

    (34) block_expr -> LBRACKET item expr RBRACKET .

    SEMICOLON       reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    ASSIGN          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    PLUS            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    MINUS           reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    MULT            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    DIVIDE          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    REMINDER        reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    AND             reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    OR              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    XOR             reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    EQUALS          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    NE              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    LT              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    GT              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    LE              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    GE              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    RPAREN          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    RBRACKET        reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    ELSE            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    $end            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    LBRACKET        reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    LPAREN          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    WHILE           reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    LOOP            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    BREAK           reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    CONTINUE        reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    IF              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    RETURN          reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    INTEGER         reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    FLOAT           reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    TRUE            reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    FALSE           reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)
    ID              reduce using rule 34 (block_expr -> LBRACKET item expr RBRACKET .)


state 121

    (52) no_struct_literal_expr -> literal binop literal .
    (53) no_struct_literal_expr -> literal binop literal . binop literal
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    LBRACKET        reduce using rule 52 (no_struct_literal_expr -> literal binop literal .)
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 131
    arith_op                       shift and go to state 105
    bitwise_op                     shift and go to state 106
    comp_op                        shift and go to state 49

state 122

    (46) if_expr -> IF no_struct_literal_expr block_expr else_tail .

    SEMICOLON       reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    ASSIGN          reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    PLUS            reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    MINUS           reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    MULT            reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    DIVIDE          reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    REMINDER        reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    AND             reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    OR              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    XOR             reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    EQUALS          reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    NE              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    LT              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    GT              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    LE              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    GE              reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    RPAREN          reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)
    RBRACKET        reduce using rule 46 (if_expr -> IF no_struct_literal_expr block_expr else_tail .)


state 123

    (47) else_tail -> ELSE . if_expr
    (48) else_tail -> ELSE . block_expr
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET

    IF              shift and go to state 38
    LBRACKET        shift and go to state 30

    if_expr                        shift and go to state 132
    block_expr                     shift and go to state 133

state 124

    (13) let_decl -> LET MUT ID COLON type . init SEMICOLON
    (14) let_decl -> LET MUT ID COLON type . SEMICOLON
    (21) init -> . ASSIGN expr
    (22) init -> . expr
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    SEMICOLON       shift and go to state 135
    ASSIGN          shift and go to state 88
    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    init                           shift and go to state 134
    expr                           shift and go to state 89
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 125

    (15) let_decl -> LET MUT ID init SEMICOLON .

    $end            reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    LBRACKET        reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    LPAREN          reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    WHILE           reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    LOOP            reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    BREAK           reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    CONTINUE        reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    IF              reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    RETURN          reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    INTEGER         reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    FLOAT           reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    TRUE            reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    FALSE           reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)
    ID              reduce using rule 15 (let_decl -> LET MUT ID init SEMICOLON .)


state 126

    (17) let_decl -> LET ID COLON type init . SEMICOLON

    SEMICOLON       shift and go to state 136


state 127

    (18) let_decl -> LET ID COLON type SEMICOLON .

    $end            reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    LBRACKET        reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    LPAREN          reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    WHILE           reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    LOOP            reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    BREAK           reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    CONTINUE        reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    IF              reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    RETURN          reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    INTEGER         reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    FLOAT           reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    TRUE            reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    FALSE           reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)
    ID              reduce using rule 18 (let_decl -> LET ID COLON type SEMICOLON .)


state 128

    (10) fn_item -> FN ID LPAREN RPAREN block_expr .

    $end            reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    LBRACKET        reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    LPAREN          reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    WHILE           reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    LOOP            reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    BREAK           reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    CONTINUE        reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    IF              reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    RETURN          reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    INTEGER         reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    FLOAT           reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    TRUE            reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    FALSE           reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)
    ID              reduce using rule 10 (fn_item -> FN ID LPAREN RPAREN block_expr .)


state 129

    (11) const_item -> CONST ID COLON type ASSIGN . expr SEMICOLON
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 137
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 130

    (12) static_item -> STATIC ID COLON type ASSIGN . expr SEMICOLON
    (23) expr -> . literal
    (24) expr -> . block_expr
    (25) expr -> . binop_expr
    (26) expr -> . paren_expr
    (27) expr -> . while_expr
    (28) expr -> . loop_expr
    (29) expr -> . break_expr
    (30) expr -> . continue_expr
    (31) expr -> . if_expr
    (32) expr -> . return_expr
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (33) block_expr -> . LBRACKET stmt expr RBRACKET
    (34) block_expr -> . LBRACKET item expr RBRACKET
    (35) block_expr -> . LBRACKET expr RBRACKET
    (36) binop_expr -> . expr binop expr
    (37) binop_expr -> . type_cast_expr
    (38) binop_expr -> . assignment_expr
    (39) binop_expr -> . compound_assignment_expr
    (40) paren_expr -> . LPAREN expr RPAREN
    (41) while_expr -> . WHILE no_struct_literal_expr block_expr
    (42) loop_expr -> . LOOP block_expr
    (43) break_expr -> . BREAK
    (44) continue_expr -> . CONTINUE
    (45) if_expr -> . IF no_struct_literal_expr block_expr
    (46) if_expr -> . IF no_struct_literal_expr block_expr else_tail
    (49) return_expr -> . RETURN
    (50) return_expr -> . RETURN expr
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID
    (79) type_cast_expr -> . ID AS type
    (80) assignment_expr -> . expr ASSIGN expr
    (81) compound_assignment_expr -> . expr arith_op ASSIGN expr
    (82) compound_assignment_expr -> . expr bitwise_op ASSIGN expr

    LBRACKET        shift and go to state 30
    LPAREN          shift and go to state 24
    WHILE           shift and go to state 34
    LOOP            shift and go to state 35
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 37
    IF              shift and go to state 38
    RETURN          shift and go to state 39
    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 12

    expr                           shift and go to state 138
    literal                        shift and go to state 13
    block_expr                     shift and go to state 14
    binop_expr                     shift and go to state 15
    paren_expr                     shift and go to state 16
    while_expr                     shift and go to state 17
    loop_expr                      shift and go to state 18
    break_expr                     shift and go to state 19
    continue_expr                  shift and go to state 20
    if_expr                        shift and go to state 21
    return_expr                    shift and go to state 22
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29
    type_cast_expr                 shift and go to state 31
    assignment_expr                shift and go to state 32
    compound_assignment_expr       shift and go to state 33

state 131

    (53) no_struct_literal_expr -> literal binop literal binop . literal
    (55) literal -> . num_lit
    (56) literal -> . bool_lit
    (57) literal -> . lit_suffix
    (58) num_lit -> . INTEGER
    (59) num_lit -> . FLOAT
    (60) bool_lit -> . TRUE
    (61) bool_lit -> . FALSE
    (54) lit_suffix -> . ID

    INTEGER         shift and go to state 40
    FLOAT           shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    ID              shift and go to state 76

    literal                        shift and go to state 139
    num_lit                        shift and go to state 27
    bool_lit                       shift and go to state 28
    lit_suffix                     shift and go to state 29

state 132

    (47) else_tail -> ELSE if_expr .

    SEMICOLON       reduce using rule 47 (else_tail -> ELSE if_expr .)
    ASSIGN          reduce using rule 47 (else_tail -> ELSE if_expr .)
    PLUS            reduce using rule 47 (else_tail -> ELSE if_expr .)
    MINUS           reduce using rule 47 (else_tail -> ELSE if_expr .)
    MULT            reduce using rule 47 (else_tail -> ELSE if_expr .)
    DIVIDE          reduce using rule 47 (else_tail -> ELSE if_expr .)
    REMINDER        reduce using rule 47 (else_tail -> ELSE if_expr .)
    AND             reduce using rule 47 (else_tail -> ELSE if_expr .)
    OR              reduce using rule 47 (else_tail -> ELSE if_expr .)
    XOR             reduce using rule 47 (else_tail -> ELSE if_expr .)
    EQUALS          reduce using rule 47 (else_tail -> ELSE if_expr .)
    NE              reduce using rule 47 (else_tail -> ELSE if_expr .)
    LT              reduce using rule 47 (else_tail -> ELSE if_expr .)
    GT              reduce using rule 47 (else_tail -> ELSE if_expr .)
    LE              reduce using rule 47 (else_tail -> ELSE if_expr .)
    GE              reduce using rule 47 (else_tail -> ELSE if_expr .)
    RPAREN          reduce using rule 47 (else_tail -> ELSE if_expr .)
    RBRACKET        reduce using rule 47 (else_tail -> ELSE if_expr .)


state 133

    (48) else_tail -> ELSE block_expr .

    SEMICOLON       reduce using rule 48 (else_tail -> ELSE block_expr .)
    ASSIGN          reduce using rule 48 (else_tail -> ELSE block_expr .)
    PLUS            reduce using rule 48 (else_tail -> ELSE block_expr .)
    MINUS           reduce using rule 48 (else_tail -> ELSE block_expr .)
    MULT            reduce using rule 48 (else_tail -> ELSE block_expr .)
    DIVIDE          reduce using rule 48 (else_tail -> ELSE block_expr .)
    REMINDER        reduce using rule 48 (else_tail -> ELSE block_expr .)
    AND             reduce using rule 48 (else_tail -> ELSE block_expr .)
    OR              reduce using rule 48 (else_tail -> ELSE block_expr .)
    XOR             reduce using rule 48 (else_tail -> ELSE block_expr .)
    EQUALS          reduce using rule 48 (else_tail -> ELSE block_expr .)
    NE              reduce using rule 48 (else_tail -> ELSE block_expr .)
    LT              reduce using rule 48 (else_tail -> ELSE block_expr .)
    GT              reduce using rule 48 (else_tail -> ELSE block_expr .)
    LE              reduce using rule 48 (else_tail -> ELSE block_expr .)
    GE              reduce using rule 48 (else_tail -> ELSE block_expr .)
    RPAREN          reduce using rule 48 (else_tail -> ELSE block_expr .)
    RBRACKET        reduce using rule 48 (else_tail -> ELSE block_expr .)


state 134

    (13) let_decl -> LET MUT ID COLON type init . SEMICOLON

    SEMICOLON       shift and go to state 140


state 135

    (14) let_decl -> LET MUT ID COLON type SEMICOLON .

    $end            reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    LBRACKET        reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    LPAREN          reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    WHILE           reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    LOOP            reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    BREAK           reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    CONTINUE        reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    IF              reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    RETURN          reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    INTEGER         reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    FLOAT           reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    TRUE            reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    FALSE           reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)
    ID              reduce using rule 14 (let_decl -> LET MUT ID COLON type SEMICOLON .)


state 136

    (17) let_decl -> LET ID COLON type init SEMICOLON .

    $end            reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    LBRACKET        reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    LPAREN          reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    WHILE           reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    LOOP            reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    BREAK           reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    CONTINUE        reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    IF              reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    RETURN          reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    INTEGER         reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    FLOAT           reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    TRUE            reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    FALSE           reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)
    ID              reduce using rule 17 (let_decl -> LET ID COLON type init SEMICOLON .)


state 137

    (11) const_item -> CONST ID COLON type ASSIGN expr . SEMICOLON
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    SEMICOLON       shift and go to state 141
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 138

    (12) static_item -> STATIC ID COLON type ASSIGN expr . SEMICOLON
    (36) binop_expr -> expr . binop expr
    (80) assignment_expr -> expr . ASSIGN expr
    (81) compound_assignment_expr -> expr . arith_op ASSIGN expr
    (82) compound_assignment_expr -> expr . bitwise_op ASSIGN expr
    (62) binop -> . arith_op
    (63) binop -> . bitwise_op
    (64) binop -> . comp_op
    (65) arith_op -> . PLUS
    (66) arith_op -> . MINUS
    (67) arith_op -> . MULT
    (68) arith_op -> . DIVIDE
    (69) arith_op -> . REMINDER
    (70) bitwise_op -> . AND
    (71) bitwise_op -> . OR
    (72) bitwise_op -> . XOR
    (73) comp_op -> . EQUALS
    (74) comp_op -> . NE
    (75) comp_op -> . LT
    (76) comp_op -> . GT
    (77) comp_op -> . LE
    (78) comp_op -> . GE

    SEMICOLON       shift and go to state 142
    ASSIGN          shift and go to state 46
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    MULT            shift and go to state 52
    DIVIDE          shift and go to state 53
    REMINDER        shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    XOR             shift and go to state 57
    EQUALS          shift and go to state 58
    NE              shift and go to state 59
    LT              shift and go to state 60
    GT              shift and go to state 61
    LE              shift and go to state 62
    GE              shift and go to state 63

    binop                          shift and go to state 45
    arith_op                       shift and go to state 47
    bitwise_op                     shift and go to state 48
    comp_op                        shift and go to state 49

state 139

    (53) no_struct_literal_expr -> literal binop literal binop literal .

    LBRACKET        reduce using rule 53 (no_struct_literal_expr -> literal binop literal binop literal .)


state 140

    (13) let_decl -> LET MUT ID COLON type init SEMICOLON .

    $end            reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    LBRACKET        reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    LPAREN          reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    WHILE           reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    LOOP            reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    BREAK           reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    CONTINUE        reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    IF              reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    RETURN          reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    INTEGER         reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    FLOAT           reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    TRUE            reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    FALSE           reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)
    ID              reduce using rule 13 (let_decl -> LET MUT ID COLON type init SEMICOLON .)


state 141

    (11) const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .

    $end            reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    LBRACKET        reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    LOOP            reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    BREAK           reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    CONTINUE        reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    IF              reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    INTEGER         reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    TRUE            reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    FALSE           reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)
    ID              reduce using rule 11 (const_item -> CONST ID COLON type ASSIGN expr SEMICOLON .)


state 142

    (12) static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .

    $end            reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    LBRACKET        reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    LOOP            reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    BREAK           reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    CONTINUE        reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    IF              reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    INTEGER         reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    TRUE            reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    FALSE           reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)
    ID              reduce using rule 12 (static_item -> STATIC ID COLON type ASSIGN expr SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 73 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 73 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 73 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 73 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 73 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 73 resolved as shift
WARNING: shift/reduce conflict for IF in state 73 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 73 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 73 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 73 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 73 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MULT in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for REMINDER in state 79 resolved as shift
WARNING: shift/reduce conflict for AND in state 79 resolved as shift
WARNING: shift/reduce conflict for OR in state 79 resolved as shift
WARNING: shift/reduce conflict for XOR in state 79 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for NE in state 79 resolved as shift
WARNING: shift/reduce conflict for LT in state 79 resolved as shift
WARNING: shift/reduce conflict for GT in state 79 resolved as shift
WARNING: shift/reduce conflict for LE in state 79 resolved as shift
WARNING: shift/reduce conflict for GE in state 79 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MULT in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for REMINDER in state 80 resolved as shift
WARNING: shift/reduce conflict for AND in state 80 resolved as shift
WARNING: shift/reduce conflict for OR in state 80 resolved as shift
WARNING: shift/reduce conflict for XOR in state 80 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 80 resolved as shift
WARNING: shift/reduce conflict for NE in state 80 resolved as shift
WARNING: shift/reduce conflict for LT in state 80 resolved as shift
WARNING: shift/reduce conflict for GT in state 80 resolved as shift
WARNING: shift/reduce conflict for LE in state 80 resolved as shift
WARNING: shift/reduce conflict for GE in state 80 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MULT in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for REMINDER in state 81 resolved as shift
WARNING: shift/reduce conflict for AND in state 81 resolved as shift
WARNING: shift/reduce conflict for OR in state 81 resolved as shift
WARNING: shift/reduce conflict for XOR in state 81 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 81 resolved as shift
WARNING: shift/reduce conflict for NE in state 81 resolved as shift
WARNING: shift/reduce conflict for LT in state 81 resolved as shift
WARNING: shift/reduce conflict for GT in state 81 resolved as shift
WARNING: shift/reduce conflict for LE in state 81 resolved as shift
WARNING: shift/reduce conflict for GE in state 81 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MULT in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for REMINDER in state 108 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for XOR in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 108 resolved as shift
WARNING: shift/reduce conflict for NE in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LE in state 108 resolved as shift
WARNING: shift/reduce conflict for GE in state 108 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MULT in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for REMINDER in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for XOR in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 109 resolved as shift
WARNING: shift/reduce conflict for NE in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for LE in state 109 resolved as shift
WARNING: shift/reduce conflict for GE in state 109 resolved as shift
